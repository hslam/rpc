// Code generated by protoc-gen-hslam. DO NOT EDIT.
// source: arith.proto

package service

import (
	"fmt"
	"github.com/hslam/code"
)

//ArithRequest defines the request of arith.
type ArithRequest struct {
	A int32
	B int32
}

// Size returns the size of the buffer required to represent the data when encoded.
func (a *ArithRequest) Size() int {
	var size uint64
	size += 11
	size += 11
	return int(size)
}

// Marshal returns the encoded bytes.
func (a *ArithRequest) Marshal() ([]byte, error) {
	size := a.Size()
	buf := make([]byte, size)
	n, err := a.MarshalTo(buf[:size])
	if err != nil {
		return nil, err
	}
	return buf[:n], nil
}

// MarshalTo marshals into buf and returns the number of bytes.
func (a *ArithRequest) MarshalTo(buf []byte) (int, error) {
	var size = uint64(a.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if a.A != 0 {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], uint64(a.A))
		offset += n
	}
	if a.B != 0 {
		buf[offset] = 2<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], uint64(a.B))
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (a *ArithRequest) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var t uint64
			n = code.DecodeVarint(data[offset:], &t)
			a.A = int32(t)
			offset += n
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var t uint64
			n = code.DecodeVarint(data[offset:], &t)
			a.B = int32(t)
			offset += n
		}
	}
	return nil
}

//ArithResponse defines the response of arith.
type ArithResponse struct {
	Pro int32 //product
}

// Size returns the size of the buffer required to represent the data when encoded.
func (a *ArithResponse) Size() int {
	var size uint64
	size += 11
	return int(size)
}

// Marshal returns the encoded bytes.
func (a *ArithResponse) Marshal() ([]byte, error) {
	size := a.Size()
	buf := make([]byte, size)
	n, err := a.MarshalTo(buf[:size])
	if err != nil {
		return nil, err
	}
	return buf[:n], nil
}

// MarshalTo marshals into buf and returns the number of bytes.
func (a *ArithResponse) MarshalTo(buf []byte) (int, error) {
	var size = uint64(a.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if a.Pro != 0 {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], uint64(a.Pro))
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (a *ArithResponse) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pro", wireType)
			}
			var t uint64
			n = code.DecodeVarint(data[offset:], &t)
			a.Pro = int32(t)
			offset += n
		}
	}
	return nil
}
