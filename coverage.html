
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">hslam.com/git/x/rpc/batch.go (87.7%)</option>
				
				<option value="file1">hslam.com/git/x/rpc/call.go (0.0%)</option>
				
				<option value="file2">hslam.com/git/x/rpc/client.go (51.6%)</option>
				
				<option value="file3">hslam.com/git/x/rpc/codec.go (0.0%)</option>
				
				<option value="file4">hslam.com/git/x/rpc/codec_batch.go (61.0%)</option>
				
				<option value="file5">hslam.com/git/x/rpc/codec_client.go (80.0%)</option>
				
				<option value="file6">hslam.com/git/x/rpc/codec_funcs.go (62.5%)</option>
				
				<option value="file7">hslam.com/git/x/rpc/codec_msg.go (61.3%)</option>
				
				<option value="file8">hslam.com/git/x/rpc/codec_request.go (66.1%)</option>
				
				<option value="file9">hslam.com/git/x/rpc/codec_response.go (55.6%)</option>
				
				<option value="file10">hslam.com/git/x/rpc/codec_server.go (77.1%)</option>
				
				<option value="file11">hslam.com/git/x/rpc/conn.go (77.8%)</option>
				
				<option value="file12">hslam.com/git/x/rpc/conn_http.go (61.6%)</option>
				
				<option value="file13">hslam.com/git/x/rpc/conn_http1.go (0.0%)</option>
				
				<option value="file14">hslam.com/git/x/rpc/conn_ipc.go (62.7%)</option>
				
				<option value="file15">hslam.com/git/x/rpc/conn_quic.go (64.2%)</option>
				
				<option value="file16">hslam.com/git/x/rpc/conn_tcp.go (76.5%)</option>
				
				<option value="file17">hslam.com/git/x/rpc/conn_udp.go (72.2%)</option>
				
				<option value="file18">hslam.com/git/x/rpc/conn_ws.go (82.0%)</option>
				
				<option value="file19">hslam.com/git/x/rpc/count.go (50.0%)</option>
				
				<option value="file20">hslam.com/git/x/rpc/io_multiplexing.go (54.3%)</option>
				
				<option value="file21">hslam.com/git/x/rpc/io_pipelining.go (52.3%)</option>
				
				<option value="file22">hslam.com/git/x/rpc/listener.go (81.8%)</option>
				
				<option value="file23">hslam.com/git/x/rpc/listener_http.go (47.9%)</option>
				
				<option value="file24">hslam.com/git/x/rpc/listener_ipc.go (82.1%)</option>
				
				<option value="file25">hslam.com/git/x/rpc/listener_quic.go (81.6%)</option>
				
				<option value="file26">hslam.com/git/x/rpc/listener_tcp.go (85.3%)</option>
				
				<option value="file27">hslam.com/git/x/rpc/listener_udp.go (74.5%)</option>
				
				<option value="file28">hslam.com/git/x/rpc/listener_ws.go (84.2%)</option>
				
				<option value="file29">hslam.com/git/x/rpc/logger.go (75.0%)</option>
				
				<option value="file30">hslam.com/git/x/rpc/options.go (27.7%)</option>
				
				<option value="file31">hslam.com/git/x/rpc/pool.go (0.0%)</option>
				
				<option value="file32">hslam.com/git/x/rpc/server.go (64.9%)</option>
				
				<option value="file33">hslam.com/git/x/rpc/sync_conn.go (0.0%)</option>
				
				<option value="file34">hslam.com/git/x/rpc/transport.go (0.0%)</option>
				
				<option value="file35">hslam.com/git/x/rpc/utils.go (17.2%)</option>
				
				<option value="file36">hslam.com/git/x/rpc/ws_conn.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package rpc

import (
        "sync"
        "time"
)

type batchRequestChan chan *batchRequest

type batchRequest struct {
        id         uint64
        name       string
        argsBytes  []byte
        replyBytes chan []byte
        replyError chan error
        noRequest  bool
        noResponse bool
}
type batch struct {
        mut                sync.Mutex
        reqChan            batchRequestChan
        client             *client
        readyRequests      []*batchRequest
        maxBatchRequest    int
        maxDelayNanoSecond int
        closeChan          chan bool
}

func newBatch(c *client, maxDelayNanoSecond int, maxBatchRequest int) *batch <span class="cov7" title="10">{
        b := &amp;batch{
                reqChan:            make(chan *batchRequest, DefaultMaxCacheRequest),
                client:             c,
                readyRequests:      make([]*batchRequest, 0),
                maxBatchRequest:    maxBatchRequest,
                maxDelayNanoSecond: maxDelayNanoSecond,
                closeChan:          make(chan bool, 1),
        }
        go b.run()
        return b
}</span>

func (b *batch) GetMaxBatchRequest() int <span class="cov7" title="10">{
        return b.maxBatchRequest
}</span>
func (b *batch) SetMaxBatchRequest(maxBatchRequest int) <span class="cov7" title="10">{
        b.maxBatchRequest = maxBatchRequest
}</span>
func (b *batch) run() <span class="cov7" title="10">{
        go func() </span><span class="cov7" title="10">{
                for cr := range b.reqChan </span><span class="cov7" title="10">{
                        func() </span><span class="cov7" title="10">{
                                b.mut.Lock()
                                defer b.mut.Unlock()
                                b.readyRequests = append(b.readyRequests, cr)
                                if len(b.readyRequests) &gt;= b.maxBatchRequest </span><span class="cov2" title="2">{
                                        crs := b.readyRequests[:]
                                        b.readyRequests = nil
                                        b.readyRequests = make([]*batchRequest, 0)
                                        b.Ticker(crs)
                                }</span>
                        }()
                }
        }()
        <span class="cov7" title="10">tick := time.NewTicker(1 * time.Nanosecond * time.Duration(b.maxDelayNanoSecond))
        for </span><span class="cov10" title="27">{
                select </span>{
                case &lt;-b.closeChan:<span class="cov7" title="10">
                        close(b.closeChan)
                        tick.Stop()
                        tick = nil
                        goto endfor</span>
                case &lt;-tick.C:<span class="cov8" title="17">
                        func() </span><span class="cov8" title="17">{
                                b.mut.Lock()
                                defer b.mut.Unlock()
                                if len(b.readyRequests) &gt; b.maxBatchRequest </span><span class="cov0" title="0">{
                                        crs := b.readyRequests[:b.maxBatchRequest]
                                        b.readyRequests = b.readyRequests[b.maxBatchRequest:]
                                        b.Ticker(crs)
                                }</span> else<span class="cov8" title="17"> if len(b.readyRequests) &gt; 0 </span><span class="cov6" title="8">{
                                        crs := b.readyRequests[:]
                                        b.readyRequests = b.readyRequests[len(b.readyRequests):]
                                        b.Ticker(crs)
                                }</span>
                        }()
                }
        }
endfor:
}
func (b *batch) Ticker(brs []*batchRequest) <span class="cov7" title="10">{
        NoResponseCnt := 0
        var noResponse bool
        clientCodec := &amp;clientCodec{}
        clientCodec.clientID = b.client.GetID()
        clientCodec.batch = true
        clientCodec.batchingAsync = b.client.batchingAsync
        clientCodec.requests = brs
        clientCodec.compressType = b.client.compressType
        clientCodec.compressLevel = b.client.compressLevel
        clientCodec.funcsCodecType = b.client.funcsCodecType
        for _, v := range brs </span><span class="cov7" title="10">{
                if v.noResponse == true </span><span class="cov0" title="0">{
                        NoResponseCnt++
                }</span>
        }
        <span class="cov7" title="10">if NoResponseCnt == len(brs) </span><span class="cov0" title="0">{
                noResponse = true
        }</span> else<span class="cov7" title="10"> {
                noResponse = false
        }</span>
        <span class="cov7" title="10">msgBytes, err := clientCodec.Encode()
        if err == nil </span><span class="cov7" title="10">{
                if noResponse == false </span><span class="cov7" title="10">{
                        data, err := b.client.remoteCall(msgBytes)
                        if err == nil </span><span class="cov7" title="10">{
                                err := clientCodec.Decode(data)
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov7" title="10">if len(clientCodec.responses) == len(brs) </span><span class="cov7" title="10">{
                                        for i, v := range brs </span><span class="cov7" title="10">{
                                                if brs[i].id == clientCodec.responses[i].id &amp;&amp; v.noResponse == false </span><span class="cov7" title="10">{
                                                        func() </span><span class="cov7" title="10">{
                                                                defer func() </span><span class="cov7" title="10">{
                                                                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                                                                logger.Errorln("v.reply err", err)
                                                                        }</span>
                                                                }()
                                                                <span class="cov7" title="10">if clientCodec.responses[i].err != nil </span><span class="cov0" title="0">{
                                                                        v.replyError &lt;- clientCodec.responses[i].err
                                                                }</span> else<span class="cov7" title="10"> {
                                                                        v.replyBytes &lt;- clientCodec.responses[i].data
                                                                }</span>
                                                        }()
                                                }
                                        }
                                }
                        }
                } else<span class="cov0" title="0"> {
                        _ = b.client.remoteCallNoResponse(msgBytes)
                }</span>

        }
}

func (b *batch) Close() <span class="cov7" title="10">{
        close(b.reqChan)
        b.client = nil
        b.readyRequests = nil
        b.closeChan &lt;- true
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package rpc

import "time"

// Call represents an active RPC.
type Call struct {
        ServiceMethod string
        Args          interface{}
        Reply         interface{}
        Error         error
        Done          chan *Call
        start         time.Time
}

func (call *Call) done() <span class="cov0" title="0">{
        select </span>{
        case call.Done &lt;- call:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package rpc

import (
        "math/rand"
        "sync"
        "sync/atomic"
        "time"
)

//Client defines the interface of client.
type Client interface {
        GetMaxRequests() int
        GetMaxBatchRequest() int
        GetID() uint64
        GetTimeout() int64
        GetHeartbeatTimeout() int64
        GetMaxErrPerSecond() int
        GetMaxErrHeartbeat() int
        CodecName() string
        CodecType() CodecType
        Go(name string, args interface{}, reply interface{}, done chan *Call) *Call
        Call(name string, args interface{}, reply interface{}) (err error)
        CallNoRequest(name string, reply interface{}) (err error)
        CallNoResponse(name string, args interface{}) (err error)
        OnlyCall(name string) (err error)
        Ping() bool
        Close() (err error)
        Closed() bool
}

// Dial connects to an RPC server at the specified network address codec
// and returns a client.
func Dial(network, address, codec string) (Client, error) <span class="cov5" title="7">{
        transporter, err := dial(network, address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="7">return NewClient(transporter, codec)</span>
}

// DialWithOptions is like Dial but uses the specified options
// and returns a client.
func DialWithOptions(network, address, codec string, opts *Options) (Client, error) <span class="cov7" title="20">{
        transporter, err := dial(network, address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="20">return NewClientWithOptions(transporter, codec, opts)</span>
}

type client struct {
        mu               sync.RWMutex
        mutex            sync.RWMutex
        conn             Conn
        seq              uint64
        pending          map[int64]*Call
        unordered        bool
        closed           bool
        closing          bool
        closeChan        chan bool
        disconnected     bool
        hystrix          bool
        batchEnabled     bool
        batchingAsync    bool
        batch            *batch
        io               IO
        maxRequests      int
        requestChan      chan bool
        readChan         chan []byte
        writeChan        chan []byte
        finishChan       chan bool
        stopChan         chan bool
        funcsCodecType   CodecType
        compressType     CompressType
        compressLevel    CompressLevel
        clientID         uint64
        timeout          int64
        heartbeatTimeout int64
        errCntChan       chan int
        errCnt           int
        maxErrPerSecond  int
        maxErrHeartbeat  int
        errCntHeartbeat  int
        retry            bool
        noDelay          bool
}

// NewClient returns a new Client to handle requests.
func NewClient(conn Conn, codec string) (Client, error) <span class="cov5" title="7">{
        return NewClientWithOptions(conn, codec, DefaultOptions())
}</span>

// NewClientWithOptions is like NewClient but uses the specified options.
func NewClientWithOptions(conn Conn, codec string, opts *Options) (Client, error) <span class="cov8" title="27">{
        funcsCodecType, err := funcsCodecType(codec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="27">var clientID uint64 = 1
        c := &amp;client{
                clientID:         clientID,
                conn:             conn,
                pending:          make(map[int64]*Call),
                finishChan:       make(chan bool, 1),
                stopChan:         make(chan bool, 1),
                closeChan:        make(chan bool, 1),
                funcsCodecType:   funcsCodecType,
                compressLevel:    NoCompression,
                compressType:     CompressTypeNo,
                retry:            true,
                errCntChan:       make(chan int, 1000000),
                timeout:          DefaultClientTimeout,
                maxErrPerSecond:  DefaultClientMaxErrPerSecond,
                heartbeatTimeout: DefaultClientHearbeatTimeout,
                maxErrHeartbeat:  DefaultClientMaxErrHeartbeat,
        }
        c.loadOptions(opts)
        c.conn.NoDelay(c.noDelay)
        c.conn.Multiplexing(c.unordered)
        c.conn.Handle(c.readChan, c.writeChan, c.stopChan, c.finishChan)
        go c.run()
        return c, nil</span>
}
func (c *client) run() <span class="cov8" title="27">{
        go func() </span><span class="cov8" title="27">{
                for i := range c.errCntChan </span><span class="cov0" title="0">{
                        c.errCnt += i
                }</span>
        }()
        <span class="cov8" title="27">time.Sleep(time.Millisecond * time.Duration(rand.Int63n(800)))
        ticker := time.NewTicker(time.Second)
        heartbeatTicker := time.NewTicker(time.Millisecond * DefaultClientHearbeatTicker)
        retryTicker := time.NewTicker(time.Millisecond * DefaultClientRetryTicker)
        for </span><span class="cov10" title="63">{
                select </span>{
                case &lt;-c.finishChan:<span class="cov8" title="36">
                        //logger.Traceln(c.client_id,"client.run finishChan")
                        c.retryConnect()</span>
                case &lt;-heartbeatTicker.C:<span class="cov0" title="0">
                        if c.disconnected == false &amp;&amp; c.retry </span><span class="cov0" title="0">{
                                err := c.heartbeat()
                                if err != nil </span><span class="cov0" title="0">{
                                        c.errCntHeartbeat++
                                }</span> else<span class="cov0" title="0"> {
                                        c.errCntHeartbeat = 0
                                }</span>
                                <span class="cov0" title="0">if c.errCntHeartbeat &gt;= c.maxErrHeartbeat </span><span class="cov0" title="0">{
                                        c.retryConnect()
                                        c.errCntHeartbeat = 0
                                }</span>
                        }
                case &lt;-retryTicker.C:<span class="cov0" title="0">
                        if c.disconnected == true &amp;&amp; c.retry </span><span class="cov0" title="0">{
                                c.retryConnect()
                        }</span>
                case &lt;-c.closeChan:<span class="cov8" title="27">
                        func() </span><span class="cov8" title="27">{
                                defer func() </span><span class="cov8" title="27">{
                                        if err := recover(); err != nil </span>{<span class="cov8" title="27">
                                        }</span>
                                }()
                                <span class="cov8" title="27">c.stopChan &lt;- true</span>
                        }()
                        <span class="cov8" title="27">close(c.closeChan)
                        ticker.Stop()
                        ticker = nil
                        retryTicker.Stop()
                        retryTicker = nil
                        heartbeatTicker.Stop()
                        heartbeatTicker = nil
                        goto endfor</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        if !c.retry </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">if c.errCnt &gt;= DefaultClientMaxErrPerSecond </span><span class="cov0" title="0">{
                                c.hystrix = true
                        }</span> else<span class="cov0" title="0"> {
                                c.hystrix = false
                        }</span>
                        <span class="cov0" title="0">c.errCnt = 0</span>
                }
        }
endfor:
}
func (c *client) retryConnect() <span class="cov8" title="36">{
        if !c.retry </span><span class="cov8" title="36">{
                return
        }</span>
        <span class="cov0" title="0">c.disconnect()
        err := c.conn.Retry()
        if err != nil </span><span class="cov0" title="0">{
                c.hystrix = true
                logger.Traceln(c.clientID, "retry connection err ", err)
        }</span> else<span class="cov0" title="0"> {
                logger.Traceln(c.clientID, "retry connection success")
                c.disconnected = false
                c.hystrix = false
                c.io.Retry()
        }</span>
}
func (c *client) loadOptions(opts *Options) <span class="cov8" title="27">{
        opts.Check()
        c.setMaxRequests(opts.MaxRequests)
        if opts.Pipelining </span><span class="cov6" title="10">{
                c.enablePipelining()
        }</span> else<span class="cov7" title="17"> if opts.Multiplexing </span><span class="cov7" title="17">{
                c.enableMultiplexing()
        }</span> else<span class="cov0" title="0"> {
                c.enablePipelining()
        }</span>
        <span class="cov8" title="27">if opts.Batching </span><span class="cov6" title="10">{
                c.enableBatching()
                if opts.Multiplexing </span><span class="cov4" title="5">{
                        c.enableBatchingAsync()
                }</span>
                <span class="cov6" title="10">if opts.MaxBatchRequest &gt; c.GetMaxBatchRequest() </span><span class="cov0" title="0">{
                        c.setMaxBatchRequest(opts.MaxBatchRequest)
                }</span>
        }
        <span class="cov8" title="27">c.setCompressType(opts.CompressType)
        c.setCompressLevel(opts.CompressLevel)
        c.setID(opts.ID)
        c.setTimeout(opts.Timeout)
        c.setHeartbeatTimeout(opts.HeartbeatTimeout)
        c.setMaxErrPerSecond(opts.MaxErrPerSecond)
        c.setMaxErrHeartbeat(opts.MaxErrHeartbeat)
        if !opts.Retry </span><span class="cov0" title="0">{
                c.disableRetry()
        }</span>
        <span class="cov8" title="27">c.setNoDelay(opts.noDelay)</span>
}
func (c *client) setNoDelay(enable bool) <span class="cov8" title="27">{
        c.noDelay = enable
}</span>
func (c *client) setMaxRequests(max int) <span class="cov8" title="27">{
        c.maxRequests = max + 1
        c.readChan = make(chan []byte, c.maxRequests)
        c.writeChan = make(chan []byte, c.maxRequests)
        c.requestChan = make(chan bool, c.maxRequests)
        if c.io != nil </span><span class="cov0" title="0">{
                c.io.ResetMaxRequests(c.maxRequests)
                c.io.Reset(c.readChan, c.writeChan)
        }</span>
}

//GetMaxRequests returns the number of max requests.
func (c *client) GetMaxRequests() int <span class="cov0" title="0">{
        return c.maxRequests - 1
}</span>

func (c *client) enablePipelining() <span class="cov6" title="10">{
        c.unordered = false
        if c.maxRequests == 0 || c.readChan == nil || c.writeChan == nil </span><span class="cov0" title="0">{
                c.setMaxRequests(DefaultMaxRequests)
        }</span>
        <span class="cov6" title="10">if c.io != nil </span><span class="cov0" title="0">{
                c.io.Close()
        }</span>
        <span class="cov6" title="10">c.io = newPipeline(c.maxRequests, c.readChan, c.writeChan)</span>
}

func (c *client) enableMultiplexing() <span class="cov7" title="17">{
        c.unordered = true
        if c.maxRequests == 0 || c.readChan == nil || c.writeChan == nil </span><span class="cov0" title="0">{
                c.setMaxRequests(DefaultMaxRequests)
        }</span>
        <span class="cov7" title="17">if c.io != nil </span><span class="cov0" title="0">{
                c.io.Close()
        }</span>
        <span class="cov7" title="17">c.io = newMultiplex(c, c.maxRequests, c.readChan, c.writeChan)</span>
}
func (c *client) enableBatching() <span class="cov6" title="10">{
        c.batchEnabled = true
        c.batch = newBatch(c, DefaultMaxDelayNanoSecond*c.conn.TickerFactor(), DefaultMaxBatchRequest*c.conn.BatchFactor())
        c.batch.SetMaxBatchRequest(DefaultMaxBatchRequest * c.conn.BatchFactor())
}</span>
func (c *client) enableBatchingAsync() <span class="cov4" title="5">{
        c.batchingAsync = true
}</span>
func (c *client) setMaxBatchRequest(max int) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if max &lt;= 0 </span><span class="cov0" title="0">{
                return ErrSetMaxBatchRequest
        }</span>
        <span class="cov0" title="0">c.batch.SetMaxBatchRequest(max)
        return nil</span>
}

//GetMaxBatchRequest returns the number of max batch requests.
func (c *client) GetMaxBatchRequest() int <span class="cov6" title="10">{
        c.mu.Lock()
        defer c.mu.Unlock()
        return c.batch.GetMaxBatchRequest()
}</span>

func (c *client) setCompressType(compressType CompressType) <span class="cov8" title="27">{
        c.compressType = compressType
        c.compressLevel = DefaultCompression
}</span>
func (c *client) setCompressLevel(level CompressLevel) <span class="cov8" title="27">{
        c.compressLevel = level
}</span>
func (c *client) setID(id uint64) error <span class="cov8" title="27">{
        c.clientID = id
        return nil
}</span>

//GetID returns the client id.
func (c *client) GetID() uint64 <span class="cov6" title="10">{
        c.mu.Lock()
        defer c.mu.Unlock()
        return c.clientID
}</span>
func (c *client) setTimeout(timeout int64) error <span class="cov8" title="27">{
        c.timeout = timeout
        return nil
}</span>

//GetTimeout returns the request timeout.
func (c *client) GetTimeout() int64 <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        return c.timeout
}</span>

func (c *client) setHeartbeatTimeout(timeout int64) error <span class="cov8" title="27">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if timeout &lt;= 0 </span><span class="cov0" title="0">{
                return ErrSetTimeout
        }</span>
        <span class="cov8" title="27">c.heartbeatTimeout = timeout
        return nil</span>
}

//GetHeartbeatTimeout returns the heartbeat timeout.
func (c *client) GetHeartbeatTimeout() int64 <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        return c.heartbeatTimeout
}</span>
func (c *client) setMaxErrPerSecond(maxErrPerSecond int) error <span class="cov8" title="27">{
        if maxErrPerSecond &lt;= 0 </span><span class="cov0" title="0">{
                return ErrSetMaxErrPerSecond
        }</span>
        <span class="cov8" title="27">c.maxErrPerSecond = maxErrPerSecond
        return nil</span>
}

//GetMaxErrPerSecond returns the number of max errors per second.
func (c *client) GetMaxErrPerSecond() int <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        return c.maxErrPerSecond
}</span>
func (c *client) setMaxErrHeartbeat(maxErrHeartbeat int) error <span class="cov8" title="27">{
        if maxErrHeartbeat &lt;= 0 </span><span class="cov0" title="0">{
                return ErrSetMaxErrHeartbeat
        }</span>
        <span class="cov8" title="27">c.maxErrHeartbeat = maxErrHeartbeat
        return nil</span>
}

//GetMaxErrHeartbeat returns the number of max heartbeat errors.
func (c *client) GetMaxErrHeartbeat() int <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        return c.maxErrHeartbeat
}</span>

//CodecName returns the codec name.
func (c *client) CodecName() string <span class="cov0" title="0">{
        return funcsCodecName(c.funcsCodecType)
}</span>

//CodecType returns the codec type.
func (c *client) CodecType() CodecType <span class="cov0" title="0">{
        return c.funcsCodecType
}</span>

// Go invokes the function asynchronously. It returns the Call structure representing
// the invocation. The done channel will signal when the call is complete by returning
// the same Call object. If done is nil, Go will allocate a new channel.
// If non-nil, done must be buffered or Go will deliberately crash.
func (c *client) Go(name string, args interface{}, reply interface{}, done chan *Call) *Call <span class="cov6" title="10">{
        defer func() </span><span class="cov6" title="10">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Go failed:", err)
                }</span>
        }()
        <span class="cov6" title="10">call := new(Call)
        //call.start=time.Now()
        call.ServiceMethod = name
        call.Args = args
        call.Reply = reply
        if done == nil </span><span class="cov0" title="0">{
                done = make(chan *Call, 10) // buffered.
        }</span> else<span class="cov6" title="10"> {
                // If caller passes done != nil, it must arrange that
                // done has enough buffer for the number of simultaneous
                // RPCs that will be using that channel. If the channel
                // is totally unbuffered, it's best not to run at all.
                if cap(done) == 0 </span><span class="cov0" title="0">{
                        logger.Panic("rpc: done channel is unbuffered")
                }</span>
        }
        <span class="cov6" title="10">call.Done = done
        if c.hystrix </span><span class="cov0" title="0">{
                call.Error = ErrHystrix
                call.done()
                return call
        }</span>
        <span class="cov6" title="10">if c.unordered </span><span class="cov0" title="0">{
                go func(call *Call) </span><span class="cov0" title="0">{
                        err := c.Call(call.ServiceMethod, call.Args, call.Reply)
                        if err != nil </span><span class="cov0" title="0">{
                                call.Error = err
                        }</span>
                        <span class="cov0" title="0">call.done()</span>
                }(call)
        } else<span class="cov6" title="10"> {
                c.send(call)
        }</span>
        <span class="cov6" title="10">return call</span>
}

// Call invokes the named function, waits for it to complete, and returns its error status.
func (c *client) Call(name string, args interface{}, reply interface{}) (err error) <span class="cov8" title="27">{
        if !c.unordered </span><span class="cov6" title="10">{
                call := &lt;-c.Go(name, args, reply, make(chan *Call, 1)).Done
                return call.Error
        }</span>
        <span class="cov7" title="17">defer func() </span><span class="cov7" title="17">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Call failed:", err)
                }</span>
        }()
        <span class="cov7" title="17">if c.hystrix </span><span class="cov0" title="0">{
                return ErrHystrix
        }</span>
        <span class="cov7" title="17">err = c.call(name, args, reply)
        if err != nil </span><span class="cov0" title="0">{
                c.errCntChan &lt;- 1
        }</span>
        <span class="cov7" title="17">return</span>
}

// CallNoRequest invokes the named function but doesn't use args, waits for it to complete, and returns its error status.
func (c *client) CallNoRequest(name string, reply interface{}) (err error) <span class="cov0" title="0">{
        if !c.unordered </span><span class="cov0" title="0">{
                call := &lt;-c.Go(name, nil, reply, make(chan *Call, 1)).Done
                return call.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Call failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">if c.hystrix </span><span class="cov0" title="0">{
                return ErrHystrix
        }</span>
        <span class="cov0" title="0">err = c.call(name, nil, reply)
        if err != nil </span><span class="cov0" title="0">{
                c.errCntChan &lt;- 1
        }</span>
        <span class="cov0" title="0">return</span>
}

// CallNoResponse invokes the named function but doesn't return reply, waits for it to complete, and returns its error status.
func (c *client) CallNoResponse(name string, args interface{}) (err error) <span class="cov0" title="0">{
        if !c.unordered </span><span class="cov0" title="0">{
                call := &lt;-c.Go(name, args, nil, make(chan *Call, 1)).Done
                return call.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("CallNoResponse failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">if c.hystrix </span><span class="cov0" title="0">{
                return ErrHystrix
        }</span>
        <span class="cov0" title="0">err = c.call(name, args, nil)
        if err != nil </span><span class="cov0" title="0">{
                c.errCntChan &lt;- 1
        }</span>
        <span class="cov0" title="0">return</span>
}

// OnlyCall invokes the named function but doesn't use args and doesn't return reply, waits for it to complete, and returns its error status.
func (c *client) OnlyCall(name string) (err error) <span class="cov0" title="0">{
        if !c.unordered </span><span class="cov0" title="0">{
                call := &lt;-c.Go(name, nil, nil, make(chan *Call, 1)).Done
                return call.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("OnlyCall failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">if c.hystrix </span><span class="cov0" title="0">{
                return ErrHystrix
        }</span>
        <span class="cov0" title="0">err = c.call(name, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                c.errCntChan &lt;- 1
        }</span>
        <span class="cov0" title="0">return</span>
}

// Ping is NOT ICMP ping, this is just used to test whether a connection is still alive.
func (c *client) Ping() bool <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("client.Ping failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">err := c.heartbeat()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
func (c *client) disableRetry() <span class="cov0" title="0">{
        c.retry = false
}</span>
func (c *client) remoteCall(b []byte) ([]byte, error) <span class="cov7" title="22">{
        defer func() </span><span class="cov7" title="22">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("client.RemoteCall failed:", err)
                }</span>
        }()
        <span class="cov7" title="22">c.requestChan &lt;- true
        cbChan := make(chan []byte, 1)
        c.io.RequestChan() &lt;- c.io.NewRequest(0, b, false, cbChan)
        data, ok := &lt;-cbChan
        &lt;-c.requestChan
        if ok </span><span class="cov7" title="22">{
                return data, nil
        }</span>
        <span class="cov0" title="0">return nil, ErrRemoteCall</span>
}
func (c *client) remoteGo(b []byte, cbChan chan []byte) <span class="cov4" title="5">{
        defer func() </span><span class="cov4" title="5">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("client.RemoteCall failed:", err)
                }</span>
        }()
        <span class="cov4" title="5">c.requestChan &lt;- true
        c.io.RequestChan() &lt;- c.io.NewRequest(0, b, false, cbChan)</span>
}
func (c *client) remoteCallNoResponse(b []byte) error <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("client.RemoteCallNoResponse failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">c.requestChan &lt;- true
        cbChan := make(chan []byte, 1)
        c.io.RequestChan() &lt;- c.io.NewRequest(0, b, true, cbChan)
        &lt;-cbChan
        &lt;-c.requestChan
        return nil</span>
}
func (c *client) disconnect() (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("client.Disconnect failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">if !c.conn.Closed() </span><span class="cov0" title="0">{
                logger.Traceln(c.clientID, "client conn Closed", c.conn.Closed())
                c.stopChan &lt;- true
                time.Sleep(time.Millisecond * 200)
        }</span>
        <span class="cov0" title="0">c.disconnected = true
        return c.conn.Close()</span>
}

// Close closes the connection
func (c *client) Close() (err error) <span class="cov8" title="27">{
        c.closing = true
        defer func() </span><span class="cov8" title="27">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("client.Close failed:", err)
                }</span>
                <span class="cov8" title="27">c.closing = false</span>
        }()
        <span class="cov8" title="27">if c.closed </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="27">c.closed = true
        c.retry = false
        if c.batch != nil </span><span class="cov6" title="10">{
                c.batch.Close()
        }</span>
        <span class="cov8" title="27">if c.io != nil </span><span class="cov8" title="27">{
                c.io.Close()
        }</span>
        <span class="cov8" title="27">c.closeChan &lt;- true
        close(c.writeChan)
        close(c.readChan)
        close(c.stopChan)
        close(c.finishChan)
        close(c.errCntChan)
        close(c.requestChan)
        return c.conn.Close()</span>
}

// Closed returns the closed
func (c *client) Closed() bool <span class="cov0" title="0">{
        return c.closed || c.closing
}</span>

func (c *client) heartbeat() (err error) <span class="cov0" title="0">{
        uid := c.getSeq()
        msg := &amp;msg{}
        msg.id = uid
        msg.msgType = MsgType(MsgTypeHea)
        msgBytes, _ := msg.Encode()
        ch := make(chan int)
        go func() </span><span class="cov0" title="0">{
                var data []byte
                data, err = c.remoteCall(msgBytes)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Write error: ", err)
                        ch &lt;- 1
                        return
                }</span>
                <span class="cov0" title="0">err = msg.Decode(data)
                if err == nil </span><span class="cov0" title="0">{
                        if msg.id != uid </span><span class="cov0" title="0">{
                                err = ErrClientID
                        }</span>
                }
                <span class="cov0" title="0">ch &lt;- 1
                return</span>
        }()
        <span class="cov0" title="0">select </span>{
        case &lt;-ch:<span class="cov0" title="0"></span>
        case &lt;-time.After(time.Millisecond * time.Duration(c.heartbeatTimeout)):<span class="cov0" title="0">
                err = ErrTimeOut</span>
        }
        <span class="cov0" title="0">return err</span>
}

func (c *client) call(name string, args interface{}, reply interface{}) (err error) <span class="cov7" title="17">{
        if c.batchEnabled </span><span class="cov4" title="5">{
                cr := &amp;batchRequest{
                        id:         uint64(c.getSeq()),
                        name:       name,
                        noResponse: false,
                }
                if args != nil </span><span class="cov4" title="5">{
                        argsBytes, err := argsEncode(args, c.funcsCodecType)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("ArgsEncode error: ", err)
                        }</span>
                        <span class="cov4" title="5">cr.argsBytes = argsBytes
                        cr.noRequest = false</span>
                } else<span class="cov0" title="0"> {
                        cr.argsBytes = nil
                        cr.noRequest = true
                }</span>
                <span class="cov4" title="5">if reply != nil </span><span class="cov4" title="5">{
                        cr.replyBytes = make(chan []byte, 1)
                        cr.replyError = make(chan error, 1)
                        cr.noResponse = false
                }</span> else<span class="cov0" title="0"> {
                        cr.noResponse = true
                }</span>
                <span class="cov4" title="5">c.batch.reqChan &lt;- cr
                if cr.noResponse </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov4" title="5">if c.timeout &gt; 0 </span><span class="cov0" title="0">{
                        select </span>{
                        case bytes, ok := &lt;-cr.replyBytes:<span class="cov0" title="0">
                                if ok </span><span class="cov0" title="0">{
                                        return replyDecode(bytes, reply, c.funcsCodecType)
                                }</span>
                        case err, ok := &lt;-cr.replyError:<span class="cov0" title="0">
                                if ok </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        case &lt;-time.After(time.Millisecond * time.Duration(c.timeout)):<span class="cov0" title="0">
                                close(cr.replyBytes)
                                close(cr.replyError)
                                return ErrTimeOut</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov4" title="5">select </span>{
                case bytes, ok := &lt;-cr.replyBytes:<span class="cov4" title="5">
                        if ok </span><span class="cov4" title="5">{
                                return replyDecode(bytes, reply, c.funcsCodecType)
                        }</span>
                case err, ok := &lt;-cr.replyError:<span class="cov0" title="0">
                        if ok </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov6" title="12">clientCodec := &amp;clientCodec{}
        clientCodec.clientID = c.clientID
        clientCodec.reqID = uint64(c.getSeq())
        clientCodec.name = name
        clientCodec.compressType = c.compressType
        clientCodec.compressLevel = c.compressLevel
        clientCodec.funcsCodecType = c.funcsCodecType
        if args != nil </span><span class="cov6" title="12">{
                clientCodec.args = args
                clientCodec.noRequest = false
        }</span> else<span class="cov0" title="0"> {
                clientCodec.args = nil
                clientCodec.noRequest = true
        }</span>
        <span class="cov6" title="12">if reply != nil </span><span class="cov6" title="12">{
                clientCodec.noResponse = false
        }</span> else<span class="cov0" title="0"> {
                clientCodec.noResponse = true
        }</span>
        <span class="cov6" title="12">rpcReqBytes, _ := clientCodec.Encode()
        if clientCodec.noResponse </span><span class="cov0" title="0">{
                err = c.remoteCallNoResponse(rpcReqBytes)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Write error: ", err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov6" title="12">ch := make(chan int)
        go func() </span><span class="cov6" title="12">{
                var data []byte
                data, err = c.remoteCall(rpcReqBytes)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Write error: ", err)
                        ch &lt;- 1
                        return
                }</span>
                <span class="cov6" title="12">clientCodec.reply = reply
                err = clientCodec.Decode(data)
                ch &lt;- 1</span>
        }()
        <span class="cov6" title="12">if c.timeout &gt; 0 </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ch:<span class="cov0" title="0"></span>
                case &lt;-time.After(time.Millisecond * time.Duration(c.timeout)):<span class="cov0" title="0">
                        err = ErrTimeOut</span>
                }
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov6" title="12">select </span>{
        case &lt;-ch:<span class="cov6" title="12"></span>
        }
        <span class="cov6" title="12">return nil</span>

}
func (c *client) getSeq() uint64 <span class="cov8" title="32">{
        seq := atomic.AddUint64(&amp;c.seq, 1)
        return seq
}</span>
func (c *client) send(call *Call) <span class="cov6" title="10">{
        // Register this call.
        if c.closed || c.closing </span><span class="cov0" title="0">{
                call.Error = ErrShutdown
                call.done()
                return
        }</span>
        <span class="cov6" title="10">seq := c.getSeq()
        // Encode and send the request.
        if !c.batchEnabled </span><span class="cov4" title="5">{
                clientCodec := &amp;clientCodec{}
                clientCodec.clientID = c.clientID
                clientCodec.reqID = uint64(seq)
                clientCodec.name = call.ServiceMethod
                clientCodec.compressType = c.compressType
                clientCodec.compressLevel = c.compressLevel
                clientCodec.funcsCodecType = c.funcsCodecType
                if call.Args != nil </span><span class="cov4" title="5">{
                        clientCodec.args = call.Args
                        clientCodec.noRequest = false
                }</span> else<span class="cov0" title="0"> {
                        clientCodec.args = nil
                        clientCodec.noRequest = true
                }</span>
                <span class="cov4" title="5">if call.Reply != nil </span><span class="cov4" title="5">{
                        clientCodec.noResponse = false
                }</span> else<span class="cov0" title="0"> {
                        clientCodec.noResponse = true
                }</span>
                <span class="cov4" title="5">rpcReqBytes, err := clientCodec.Encode()
                if err != nil </span><span class="cov0" title="0">{
                        if call != nil </span><span class="cov0" title="0">{
                                call.Error = err
                                call.done()
                                return
                        }</span>
                }
                <span class="cov4" title="5">if clientCodec.noResponse </span><span class="cov0" title="0">{
                        err = c.remoteCallNoResponse(rpcReqBytes)
                        if call != nil </span><span class="cov0" title="0">{
                                if err != nil </span><span class="cov0" title="0">{
                                        call.Error = err
                                }</span>
                                <span class="cov0" title="0">call.done()</span>
                        }
                        <span class="cov0" title="0">return</span>
                }
                //c.mutex.Lock()
                //c.pending[seq] = call
                //c.mutex.Unlock()
                <span class="cov4" title="5">cbChan := make(chan []byte, 1)
                c.remoteGo(rpcReqBytes, cbChan)
                go func(c *client, cbChan chan []byte, call *Call) </span><span class="cov4" title="5">{
                        var data []byte
                        data, ok := &lt;-cbChan
                        &lt;-c.requestChan
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov4" title="5">clientCodec.reply = call.Reply
                        err = clientCodec.Decode(data)
                        //c.mutex.Lock()
                        //var ok bool
                        //if call ,ok= c.pending[seq];ok{
                        //        delete(c.pending, seq)
                        //}
                        //c.mutex.Unlock()
                        if err != nil </span><span class="cov0" title="0">{
                                if call != nil </span><span class="cov0" title="0">{
                                        call.Error = err
                                        call.done()
                                        return
                                }</span>
                        }
                        <span class="cov4" title="5">if call != nil </span><span class="cov4" title="5">{
                                call.Reply = clientCodec.reply
                                call.Done &lt;- call
                                return
                        }</span>
                }(c, cbChan, call)
        } else<span class="cov4" title="5"> {
                cr := &amp;batchRequest{
                        id:         uint64(c.getSeq()),
                        name:       call.ServiceMethod,
                        noResponse: false,
                }
                if call.Args != nil </span><span class="cov4" title="5">{
                        argsBytes, err := argsEncode(call.Args, c.funcsCodecType)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("ArgsEncode error: ", err)
                        }</span>
                        <span class="cov4" title="5">cr.argsBytes = argsBytes
                        cr.noRequest = false</span>
                } else<span class="cov0" title="0"> {
                        cr.argsBytes = nil
                        cr.noRequest = true
                }</span>
                <span class="cov4" title="5">if call.Reply != nil </span><span class="cov4" title="5">{
                        cr.replyBytes = make(chan []byte, 1)
                        cr.replyError = make(chan error, 1)
                        cr.noResponse = false
                }</span> else<span class="cov0" title="0"> {
                        cr.noResponse = true
                }</span>
                <span class="cov4" title="5">c.batch.reqChan &lt;- cr
                if cr.noResponse </span><span class="cov0" title="0">{
                        if call != nil </span><span class="cov0" title="0">{
                                call.done()
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                //c.mutex.Lock()
                //c.pending[seq] = call
                //c.mutex.Unlock()
                <span class="cov4" title="5">go func(cr *batchRequest, call *Call) </span><span class="cov4" title="5">{
                        select </span>{
                        case bytes, ok := &lt;-cr.replyBytes:<span class="cov4" title="5">
                                if ok </span><span class="cov4" title="5">{
                                        err := replyDecode(bytes, call.Reply, c.funcsCodecType)
                                        //c.mutex.Lock()
                                        //var ok bool
                                        //if call ,ok= c.pending[seq];ok{
                                        //        delete(c.pending, seq)
                                        //}
                                        //c.mutex.Unlock()
                                        if err != nil </span><span class="cov0" title="0">{
                                                if call != nil </span><span class="cov0" title="0">{
                                                        call.Error = err
                                                        call.done()
                                                        return
                                                }</span>
                                        }
                                        <span class="cov4" title="5">call.Done &lt;- call
                                        return</span>
                                }
                        case err, ok := &lt;-cr.replyError:<span class="cov0" title="0">
                                if ok </span><span class="cov0" title="0">{
                                        if err != nil </span><span class="cov0" title="0">{
                                                //c.mutex.Lock()
                                                //var ok bool
                                                //if call ,ok= c.pending[seq];ok{
                                                //        delete(c.pending, seq)
                                                //}
                                                //c.mutex.Unlock()
                                                if call != nil </span><span class="cov0" title="0">{
                                                        call.Error = err
                                                        call.done()
                                                        return
                                                }</span>
                                        }
                                }
                        }
                }(cr, call)
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package rpc

//Codec defines the interface of codec.
type Codec interface {
        Marshal() ([]byte, error)
        Unmarshal(b []byte) error
        Reset()
}

var rpcCodec = RPCCodecCode

//SETRPCCODEC sets rpc codec.
func SETRPCCODEC(t BasicCodecType) <span class="cov0" title="0">{
        rpcCodec = t
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package rpc

import (
        "errors"
        "hslam.com/git/x/code"
        "hslam.com/git/x/rpc/pb"
)

type batchCodec struct {
        async bool
        data  [][]byte
}

func (c *batchCodec) Encode() ([]byte, error) <span class="cov10" title="20">{
        switch rpcCodec </span>{
        case RPCCodecCode:<span class="cov10" title="20">
                return c.Marshal(nil)</span>
        case RPCCodecProtobuf:<span class="cov0" title="0">
                batch := pb.Batch{Async: c.async, Data: c.data}
                batchBytes, err := batch.Marshal()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("BatchEncode proto.Marshal error: ", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">return batchBytes, nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("this rpc_serialize is not supported")</span>
        }
}
func (c *batchCodec) Decode(b []byte) error <span class="cov10" title="20">{
        switch rpcCodec </span>{
        case RPCCodecCode:<span class="cov10" title="20">
                return c.Unmarshal(b)</span>
        case RPCCodecProtobuf:<span class="cov0" title="0">
                var batch = &amp;pb.Batch{}
                if err := batch.Unmarshal(b); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("BatchDecode proto.Unmarshal error: ", err)
                        return err
                }</span>
                <span class="cov0" title="0">c.async = batch.Async
                c.data = batch.Data
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("rpc_serialize is not supported")</span>
        }
}

func (c *batchCodec) Marshal(buf []byte) ([]byte, error) <span class="cov10" title="20">{
        var size uint64
        size++
        size += code.SizeofBytesSlice(c.data)
        if uint64(cap(buf)) &gt;= size </span><span class="cov0" title="0">{
                buf = buf[:size]
        }</span> else<span class="cov10" title="20"> {
                buf = make([]byte, size)
        }</span>
        <span class="cov10" title="20">var offset uint64
        var n uint64
        n = code.EncodeBool(buf[offset:], c.async)
        offset += n
        n = code.EncodeBytesSlice(buf[offset:], c.data)
        offset += n
        return buf, nil</span>
}
func (c *batchCodec) Unmarshal(b []byte) error <span class="cov10" title="20">{
        var offset uint64
        var n uint64
        n = code.DecodeBool(b[offset:], &amp;c.async)
        offset += n
        n = code.DecodeBytesSlice(b[offset:], &amp;c.data)
        offset += n
        return nil
}</span>
func (c *batchCodec) Reset() <span class="cov7" title="10">{
        for i, v := range c.data </span><span class="cov7" title="10">{
                c.data[i] = v[len(v):]
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package rpc

import (
        "errors"
        "hslam.com/git/x/rpc/pb"
)

type clientCodec struct {
        clientID       uint64
        reqID          uint64
        name           string
        args           interface{}
        funcsCodecType CodecType
        noRequest      bool
        noResponse     bool
        reply          interface{}
        res            *response
        batch          bool
        batchingAsync  bool
        compressType   CompressType
        compressLevel  CompressLevel
        msg            *msg
        batchCodec     *batchCodec
        requests       []*batchRequest
        responses      []*response
}

func (c *clientCodec) Encode() ([]byte, error) <span class="cov10" title="27">{
        var err error
        c.msg = &amp;msg{}
        c.msg.version = Version
        c.msg.id = c.clientID
        c.msg.msgType = MsgTypeReq
        c.msg.batch = c.batch
        c.msg.codecType = c.funcsCodecType
        c.msg.compressType = c.compressType
        c.msg.compressLevel = c.compressLevel
        if c.batch == false </span><span class="cov8" title="17">{
                var req *request
                if c.noRequest == false </span><span class="cov8" title="17">{
                        argsBytes, err := argsEncode(c.args, c.funcsCodecType)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorln("ArgsEncode error: ", err)
                                return nil, err
                        }</span>
                        <span class="cov8" title="17">req = &amp;request{c.reqID, c.name, c.noRequest, c.noResponse, argsBytes}</span>
                } else<span class="cov0" title="0"> {
                        req = &amp;request{c.reqID, c.name, c.noRequest, c.noResponse, nil}
                }</span>
                <span class="cov8" title="17">c.msg.data, err = req.Encode()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("RequestEncode error: ", err)
                        return nil, err
                }</span>
        } else<span class="cov7" title="10"> {
                reqBytesArr := make([][]byte, len(c.requests))
                c.responses = make([]*response, len(c.requests))
                for i, v := range c.requests </span><span class="cov7" title="10">{
                        req := &amp;request{v.id, v.name, v.noRequest, v.noResponse, v.argsBytes}
                        reqBytes, _ := req.Encode()
                        reqBytesArr[i] = reqBytes
                        c.responses[i] = &amp;response{}
                }</span>
                <span class="cov7" title="10">batchCodec := &amp;batchCodec{async: c.batchingAsync, data: reqBytesArr}
                c.batchCodec = batchCodec
                c.msg.data, _ = batchCodec.Encode()</span>
        }
        <span class="cov10" title="27">return c.msg.Encode()</span>
}

func (c *clientCodec) Decode(b []byte) error <span class="cov10" title="27">{
        var reqID = c.reqID
        if c.msg == nil </span><span class="cov0" title="0">{
                c.msg = &amp;msg{}
        }</span> else<span class="cov10" title="27"> {
                c.msg.Reset()
        }</span>
        <span class="cov10" title="27">err := c.msg.Decode(b)
        if c.msg.msgType != MsgType(pb.MsgType_res) </span><span class="cov0" title="0">{
                return errors.New("not be MsgType_res")
        }</span>
        <span class="cov10" title="27">if c.msg.batch == false </span><span class="cov8" title="17">{
                res := &amp;response{}
                err = res.Decode(c.msg.data)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("ResponseDecode error: ", err)
                        return err
                }</span>
                <span class="cov8" title="17">c.res = res
                if reqID == c.res.id </span><span class="cov8" title="17">{
                        if res.err != nil </span><span class="cov0" title="0">{
                                return res.err
                        }</span>
                        <span class="cov8" title="17">return replyDecode(res.data, c.reply, c.msg.codecType)</span>
                }
                <span class="cov0" title="0">return ErrReqID</span>
        }
        <span class="cov7" title="10">c.batchCodec.Reset()
        err = c.batchCodec.Decode(c.msg.data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="10">if len(c.batchCodec.data) == len(c.requests) </span><span class="cov7" title="10">{
                for i, res := range c.responses </span><span class="cov7" title="10">{
                        res.Decode(c.batchCodec.data[i])
                }</span>
        }
        <span class="cov7" title="10">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package rpc

import (
        "errors"
        "hslam.com/git/x/codec"
)

func argsEncode(args interface{}, funcsCodecType CodecType) ([]byte, error) <span class="cov7" title="27">{
        codec := funcsCodec(funcsCodecType)
        reqBytes, err := codec.Encode(args)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("ArgsEncode error: ", err)
                return nil, err
        }</span>
        <span class="cov7" title="27">return reqBytes, nil</span>
}

func argsDecode(argsBytes []byte, args interface{}, funcsCodecType CodecType) error <span class="cov7" title="27">{
        codec := funcsCodec(funcsCodecType)
        err := codec.Decode(argsBytes, args)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("ArgsDecode error: ", err)
                return err
        }</span>
        <span class="cov7" title="27">return nil</span>
}

func replyEncode(reply interface{}, funcsCodecType CodecType) ([]byte, error) <span class="cov7" title="27">{
        codec := funcsCodec(funcsCodecType)
        resBytes, err := codec.Encode(reply)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("ReplyEncode error: ", err)
                return nil, err
        }</span>
        <span class="cov7" title="27">return resBytes, nil</span>
}

func replyDecode(replyBytes []byte, reply interface{}, funcsCodecType CodecType) error <span class="cov7" title="27">{
        codec := funcsCodec(funcsCodecType)
        err := codec.Decode(replyBytes, reply)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln("ArgsDecode error: ", err)
                return err
        }</span>
        <span class="cov7" title="27">return nil</span>
}

func funcsCodecType(codec string) (CodecType, error) <span class="cov7" title="27">{
        switch codec </span>{
        case JSON:<span class="cov1" title="1">
                return FuncsCodecJSON, nil</span>
        case PROTOBUF:<span class="cov6" title="22">
                return FuncsCodecPROTOBUF, nil</span>
        case XML:<span class="cov1" title="1">
                return FuncsCodecXML, nil</span>
        case GOB:<span class="cov1" title="1">
                return FuncsCodecGOB, nil</span>
        case BYTES:<span class="cov1" title="1">
                return FuncsCodecBYTES, nil</span>
        case CODE:<span class="cov1" title="1">
                return FuncsCodecCODE, nil</span>
        default:<span class="cov0" title="0">
                return FuncsCodecINVALID, errors.New("this codec is not supported")</span>
        }
}

func funcsCodecName(funcsCodecType CodecType) string <span class="cov0" title="0">{
        switch funcsCodecType </span>{
        case FuncsCodecJSON:<span class="cov0" title="0">
                return JSON</span>
        case FuncsCodecPROTOBUF:<span class="cov0" title="0">
                return PROTOBUF</span>
        case FuncsCodecXML:<span class="cov0" title="0">
                return XML</span>
        case FuncsCodecGOB:<span class="cov0" title="0">
                return GOB</span>
        case FuncsCodecBYTES:<span class="cov0" title="0">
                return BYTES</span>
        case FuncsCodecCODE:<span class="cov0" title="0">
                return CODE</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}
func funcsCodec(funcsCodecType CodecType) codec.Codec <span class="cov10" title="108">{
        switch funcsCodecType </span>{
        case FuncsCodecJSON:<span class="cov3" title="4">
                return &amp;codec.JSONCodec{}</span>
        case FuncsCodecPROTOBUF:<span class="cov9" title="88">
                return &amp;codec.GOGOPBCodec{}</span>
        case FuncsCodecXML:<span class="cov3" title="4">
                return &amp;codec.XMLCodec{}</span>
        case FuncsCodecGOB:<span class="cov3" title="4">
                return &amp;codec.GOBCodec{}</span>
        case FuncsCodecBYTES:<span class="cov3" title="4">
                return &amp;codec.BYTESCodec{}</span>
        case FuncsCodecCODE:<span class="cov3" title="4">
                return &amp;codec.CODECodec{}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package rpc

import (
        "errors"
        "hslam.com/git/x/code"
        "hslam.com/git/x/compress"
        "hslam.com/git/x/rpc/pb"
)

type msg struct {
        version       float32
        id            uint64
        msgType       MsgType
        batch         bool
        codecType     CodecType
        compressType  CompressType
        compressLevel CompressLevel
        data          []byte
}

func (m *msg) Encode() ([]byte, error) <span class="cov8" title="54">{
        compressor := getCompressor(m.compressType, m.compressLevel)
        if compressor != nil </span><span class="cov0" title="0">{
                m.data = compressor.Compress(m.data)
        }</span>
        <span class="cov8" title="54">m.version = Version
        switch rpcCodec </span>{
        case RPCCodecCode:<span class="cov8" title="54">
                return m.Marshal(nil)</span>
        case RPCCodecProtobuf:<span class="cov0" title="0">
                var msg pb.Msg
                if m.msgType == MsgType(pb.MsgType_req) || m.msgType == MsgType(pb.MsgType_res) </span><span class="cov0" title="0">{
                        msg = pb.Msg{
                                Version:       m.version,
                                Id:            m.id,
                                MsgType:       pb.MsgType(m.msgType),
                                Batch:         m.batch,
                                Data:          m.data,
                                CodecType:     pb.CodecType(m.codecType),
                                CompressType:  pb.CompressType(m.compressType),
                                CompressLevel: pb.CompressLevel(m.compressLevel),
                        }
                }</span> else<span class="cov0" title="0"> if m.msgType == MsgType(pb.MsgType_hea) </span><span class="cov0" title="0">{
                        msg = pb.Msg{Version: m.version, Id: m.id, MsgType: pb.MsgType(m.msgType)}
                }</span>
                <span class="cov0" title="0">var data []byte
                var err error
                if data, err = msg.Marshal(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("MsgEncode proto.Unmarshal error: ", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">return data, nil</span>

        }
        <span class="cov0" title="0">return nil, errors.New("this rpc_serialize is not supported")</span>
}
func (m *msg) Decode(b []byte) error <span class="cov8" title="54">{
        m.version = 0
        m.id = 0
        m.data = nil
        m.batch = false
        m.codecType = FuncsCodecINVALID
        m.compressType = CompressTypeNo
        m.compressLevel = NoCompression
        switch rpcCodec </span>{
        case RPCCodecCode:<span class="cov8" title="54">
                err := m.Unmarshal(b)
                compressor := getCompressor(m.compressType, m.compressLevel)
                if compressor != nil </span><span class="cov0" title="0">{
                        m.data = compressor.Uncompress(m.data)
                }</span>
                <span class="cov8" title="54">return err</span>
        case RPCCodecProtobuf:<span class="cov0" title="0">
                var msg = &amp;pb.Msg{}
                if err := msg.Unmarshal(b); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("MsgDecode proto.Unmarshal error: ", err)
                        return err
                }</span>
                <span class="cov0" title="0">m.version = msg.Version
                m.id = msg.Id
                m.msgType = MsgType(msg.MsgType)
                if m.msgType == MsgTypeReq || m.msgType == MsgTypeRes </span><span class="cov0" title="0">{
                        m.data = msg.Data
                        m.batch = msg.Batch
                        m.codecType = CodecType(msg.CodecType)
                        m.compressType = CompressType(msg.CompressType)
                        m.compressLevel = CompressLevel(msg.CompressLevel)
                        compressor := getCompressor(m.compressType, m.compressLevel)
                        if compressor != nil </span><span class="cov0" title="0">{
                                m.data = compressor.Uncompress(m.data)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("this rpc_serialize is not supported")</span>
        }
}

func (m *msg) Marshal(buf []byte) ([]byte, error) <span class="cov8" title="54">{
        var size uint64
        size += 4
        size += 8
        size++
        size++
        size++
        size++
        size++
        size += code.SizeofBytes(m.data)
        if uint64(cap(buf)) &gt;= size </span><span class="cov0" title="0">{
                buf = buf[:size]
        }</span> else<span class="cov8" title="54"> {
                buf = make([]byte, size)
        }</span>
        <span class="cov8" title="54">var offset uint64
        var n uint64
        n = code.EncodeFloat32(buf[offset:], m.version)
        offset += n
        n = code.EncodeUint64(buf[offset:], m.id)
        offset += n
        n = code.EncodeUint8(buf[offset:], uint8(m.msgType))
        offset += n
        n = code.EncodeBool(buf[offset:], m.batch)
        offset += n
        n = code.EncodeUint8(buf[offset:], uint8(m.codecType))
        offset += n
        n = code.EncodeUint8(buf[offset:], uint8(m.compressType))
        offset += n
        n = code.EncodeUint8(buf[offset:], uint8(m.compressLevel))
        offset += n
        n = code.EncodeBytes(buf[offset:], m.data)
        offset += n
        return buf, nil</span>
}
func (m *msg) Unmarshal(b []byte) error <span class="cov8" title="54">{
        var offset uint64
        var n uint64
        n = code.DecodeFloat32(b[offset:], &amp;m.version)
        offset += n
        n = code.DecodeUint64(b[offset:], &amp;m.id)
        offset += n
        var msgType uint8
        n = code.DecodeUint8(b[offset:], &amp;msgType)
        m.msgType = MsgType(msgType)
        offset += n
        n = code.DecodeBool(b[offset:], &amp;m.batch)
        offset += n
        var codecType uint8
        n = code.DecodeUint8(b[offset:], &amp;codecType)
        m.codecType = CodecType(codecType)
        offset += n
        var compressType uint8
        n = code.DecodeUint8(b[offset:], &amp;compressType)
        m.compressType = CompressType(compressType)
        offset += n
        var compressLevel uint8
        n = code.DecodeUint8(b[offset:], &amp;compressLevel)
        m.compressLevel = CompressLevel(compressLevel)
        offset += n
        n = code.DecodeBytes(b[offset:], &amp;m.data)
        offset += n
        return nil
}</span>
func (m *msg) Reset() {<span class="cov7" title="27">
}</span>
func getCompressor(compressType CompressType, level CompressLevel) *compress.Compressor <span class="cov10" title="108">{
        if level == NoCompression </span><span class="cov10" title="108">{
                return nil
        }</span>
        <span class="cov0" title="0">switch compressType </span>{
        case CompressTypeFlate:<span class="cov0" title="0">
                return &amp;compress.Compressor{Type: compress.Flate, Level: compress.Level(level)}</span>
        case CompressTypeZlib:<span class="cov0" title="0">
                return &amp;compress.Compressor{Type: compress.Zlib, Level: compress.Level(level)}</span>
        case CompressTypeGzip:<span class="cov0" title="0">
                return &amp;compress.Compressor{Type: compress.Gzip, Level: compress.Level(level)}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func getCompressType(name string) CompressType <span class="cov0" title="0">{
        switch name </span>{
        case FLATE:<span class="cov0" title="0">
                return CompressTypeFlate</span>
        case ZLIB:<span class="cov0" title="0">
                return CompressTypeZlib</span>
        case GZIP:<span class="cov0" title="0">
                return CompressTypeGzip</span>
        default:<span class="cov0" title="0">
                return CompressTypeNo</span>
        }
}
func getCompressLevel(name string) CompressLevel <span class="cov0" title="0">{
        switch name </span>{
        case SPEED:<span class="cov0" title="0">
                return BestSpeed</span>
        case COMPRESSION:<span class="cov0" title="0">
                return BestCompression</span>
        case DC:<span class="cov0" title="0">
                return DefaultCompression</span>
        default:<span class="cov0" title="0">
                return NoCompression</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package rpc

import (
        "errors"
        "hslam.com/git/x/code"
        "hslam.com/git/x/rpc/pb"
)

type request struct {
        id         uint64
        method     string
        noRequest  bool
        noResponse bool
        data       []byte
}

func (r *request) Encode() ([]byte, error) <span class="cov10" title="27">{
        switch rpcCodec </span>{
        case RPCCodecCode:<span class="cov10" title="27">
                return r.Marshal(nil)</span>
        case RPCCodecProtobuf:<span class="cov0" title="0">
                req := pb.Request{
                        Id:         r.id,
                        Method:     r.method,
                        NoRequest:  r.noRequest,
                        NoResponse: r.noResponse,
                        Data:       r.data,
                }
                var data []byte
                var err error
                if data, err = req.Marshal(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("RequestEncode proto.Unmarshal error: ", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">return data, nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("this rpc_serialize is not supported")</span>
        }
}

func (r *request) Decode(b []byte) error <span class="cov10" title="27">{
        r.noResponse = false
        switch rpcCodec </span>{
        case RPCCodecCode:<span class="cov10" title="27">
                return r.Unmarshal(b)</span>
        case RPCCodecProtobuf:<span class="cov0" title="0">
                var rpcReqDecode = &amp;pb.Request{}
                if err := rpcReqDecode.Unmarshal(b); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("RequestDecode proto.Unmarshal error: ", err)
                        return err
                }</span>
                <span class="cov0" title="0">r.id = rpcReqDecode.Id
                r.method = rpcReqDecode.Method
                r.noRequest = rpcReqDecode.NoRequest
                r.noResponse = rpcReqDecode.NoResponse
                r.data = rpcReqDecode.Data</span>
        default:<span class="cov0" title="0">
                return errors.New("this rpc_serialize is not supported")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *request) Marshal(buf []byte) ([]byte, error) <span class="cov10" title="27">{
        var size uint64
        size += 8
        size += code.SizeofString(r.method)
        size++
        size++
        size += code.SizeofBytes(r.data)
        if uint64(cap(buf)) &gt;= size </span><span class="cov0" title="0">{
                buf = buf[:size]
        }</span> else<span class="cov10" title="27"> {
                buf = make([]byte, size)
        }</span>
        <span class="cov10" title="27">var offset uint64
        var n uint64
        n = code.EncodeUint64(buf[offset:], r.id)
        offset += n
        n = code.EncodeString(buf[offset:], r.method)
        offset += n
        n = code.EncodeBool(buf[offset:], r.noRequest)
        offset += n
        n = code.EncodeBool(buf[offset:], r.noResponse)
        offset += n
        n = code.EncodeBytes(buf[offset:], r.data)
        offset += n
        return buf, nil</span>
}
func (r *request) Unmarshal(b []byte) error <span class="cov10" title="27">{
        var offset uint64
        var n uint64
        n = code.DecodeUint64(b[offset:], &amp;r.id)
        offset += n
        n = code.DecodeString(b[offset:], &amp;r.method)
        offset += n
        n = code.DecodeBool(b[offset:], &amp;r.noRequest)
        offset += n
        n = code.DecodeBool(b[offset:], &amp;r.noResponse)
        offset += n
        n = code.DecodeBytes(b[offset:], &amp;r.data)
        offset += n
        return nil
}</span>
func (r *request) Reset() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package rpc

import (
        "errors"
        "fmt"
        "hslam.com/git/x/code"
        "hslam.com/git/x/rpc/pb"
)

type response struct {
        id     uint64
        data   []byte
        errMsg string
        err    error
}

func (r *response) Encode() ([]byte, error) <span class="cov10" title="27">{
        switch rpcCodec </span>{
        case RPCCodecCode:<span class="cov10" title="27">
                return r.Marshal(nil)</span>
        case RPCCodecProtobuf:<span class="cov0" title="0">
                if r.err != nil </span><span class="cov0" title="0">{
                        r.errMsg = fmt.Sprint(r.err)
                }</span>
                <span class="cov0" title="0">rpcRes := pb.Response{Id: r.id, Data: r.data, ErrMsg: r.errMsg}
                var rpcResBytes []byte
                var err error
                if rpcResBytes, err = rpcRes.Marshal(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("ResponseEncode proto.Marshal error: ", err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">return rpcResBytes, nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("this rpc_serialize is not supported")</span>
        }
}

func (r *response) Decode(b []byte) error <span class="cov10" title="27">{
        switch rpcCodec </span>{
        case RPCCodecCode:<span class="cov10" title="27">
                return r.Unmarshal(b)</span>
        case RPCCodecProtobuf:<span class="cov0" title="0">
                var rpcResDecode = &amp;pb.Response{}
                if err := rpcResDecode.Unmarshal(b); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("ResponseDecode proto.Unmarshal error: ", err)
                        return err
                }</span>
                <span class="cov0" title="0">r.id = rpcResDecode.Id
                if rpcResDecode.ErrMsg == "" </span><span class="cov0" title="0">{
                        r.data = rpcResDecode.Data
                        return nil
                }</span>
                <span class="cov0" title="0">r.err = errors.New(rpcResDecode.ErrMsg)
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("rpc_serialize is not supported")</span>
        }
}

func (r *response) Marshal(buf []byte) ([]byte, error) <span class="cov10" title="27">{
        if r.err != nil </span><span class="cov0" title="0">{
                r.errMsg = fmt.Sprint(r.err)
        }</span>
        <span class="cov10" title="27">var size uint64
        size += 8
        size += code.SizeofBytes(r.data)
        size += code.SizeofString(r.errMsg)
        if uint64(cap(buf)) &gt;= size </span><span class="cov0" title="0">{
                buf = buf[:size]
        }</span> else<span class="cov10" title="27"> {
                buf = make([]byte, size)
        }</span>
        <span class="cov10" title="27">var offset uint64
        var n uint64
        n = code.EncodeUint64(buf[offset:], r.id)
        offset += n
        n = code.EncodeBytes(buf[offset:], r.data)
        offset += n

        n = code.EncodeString(buf[offset:], r.errMsg)
        offset += n
        return buf, nil</span>
}
func (r *response) Unmarshal(b []byte) error <span class="cov10" title="27">{
        var offset uint64
        var n uint64
        n = code.DecodeUint64(b[offset:], &amp;r.id)
        offset += n
        n = code.DecodeBytes(b[offset:], &amp;r.data)
        offset += n
        n = code.DecodeString(b[offset:], &amp;r.errMsg)
        offset += n
        if r.errMsg != "" </span><span class="cov0" title="0">{
                r.err = errors.New(r.errMsg)
        }</span>
        <span class="cov10" title="27">return nil</span>
}
func (r *response) Reset() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package rpc

import (
        "fmt"
)

type serverCodec struct {
        msg        *msg
        batchCodec *batchCodec
        request    *request
        response   *response
        requests   []*request
        responses  []*response
}

func (c *serverCodec) Encode() ([]byte, error) <span class="cov10" title="27">{
        return c.msg.Encode()
}</span>

func (c *serverCodec) Decode(b []byte) error <span class="cov10" title="27">{
        msg := &amp;msg{}
        err := msg.Decode(b)
        c.msg = msg
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("ServerCodec.Decode msg error: %s", err)
                return fmt.Errorf("ServerCodec.Decode msg error: %s", err)
        }</span>
        <span class="cov10" title="27">if msg.version != Version </span><span class="cov0" title="0">{
                logger.Warnf("%.2f %.2f Version is not matched", Version, msg.version)
                return fmt.Errorf("%.2f %.2f Version is not matched", Version, msg.version)
        }</span>
        <span class="cov10" title="27">if msg.msgType == MsgTypeHea </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov10" title="27">if msg.batch </span><span class="cov7" title="10">{
                batchCodec := &amp;batchCodec{}
                batchCodec.Decode(msg.data)
                c.batchCodec = batchCodec
                length := len(batchCodec.data)
                c.requests = make([]*request, length)
                c.responses = make([]*response, length)
                for i, v := range batchCodec.data </span><span class="cov7" title="10">{
                        req := &amp;request{}
                        err := req.Decode(v)
                        if err != nil </span><span class="cov0" title="0">{
                                c.requests[i] = nil
                        }</span>
                        <span class="cov7" title="10">c.requests[i] = req
                        c.responses[i] = &amp;response{}</span>
                }
                <span class="cov7" title="10">batchCodec.data = make([][]byte, length)</span>
        } else<span class="cov8" title="17"> {
                req := &amp;request{}
                err := req.Decode(msg.data)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("ServerCodec.Decode id:%d req:%d error:%s ", msg.id, req.id, err)
                        return fmt.Errorf("ServerCodec.Decode id:%d req:%d error:%s ", msg.id, req.id, err)
                }</span>
                <span class="cov8" title="17">c.request = req
                c.response = &amp;response{}</span>
        }
        <span class="cov10" title="27">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package rpc

import (
        "errors"
)

//Conn defines the interface of conn.
type Conn interface {
        Handle(readChan chan []byte, writeChan chan []byte, stopChan chan bool, finishChan chan bool)
        NoDelay(enable bool)
        Multiplexing(enable bool)
        TickerFactor() int
        BatchFactor() int
        Retry() error
        Close() error
        Closed() bool
}

func dial(network, address string) (Conn, error) <span class="cov10" title="27">{
        switch network </span>{
        case IPC:<span class="cov6" title="7">
                return dialIPC(address)</span>
        case TCP:<span class="cov4" title="4">
                return dialTCP(address)</span>
        case UDP:<span class="cov4" title="4">
                return dialUDP(address)</span>
        case QUIC:<span class="cov4" title="4">
                return dialQUIC(address)</span>
        case WS:<span class="cov4" title="4">
                return dialWS(address)</span>
        case HTTP:<span class="cov4" title="4">
                return dialHTTP(address)</span>
        case HTTP1:<span class="cov0" title="0">
                return dialHTTP1(address)</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("this network is not suported")</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package rpc

import (
        "bufio"
        "errors"
        "hslam.com/git/x/protocol"
        "io"
        "net"
        "net/http"
)

type httpConn struct {
        conn       net.Conn
        address    string
        CanWork    bool
        closed     bool
        noDelay    bool
        readChan   chan []byte
        writeChan  chan []byte
        stopChan   chan bool
        finishChan chan bool
}

func dialHTTP(address string) (Conn, error) <span class="cov5" title="4">{
        var err error
        conn, err := net.Dial("tcp", address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="4">io.WriteString(conn, "CONNECT "+HTTPPath+" HTTP/1.1\n\n")

        // Require successful HTTP response
        // before switching to RPC protocol.
        resp, err := http.ReadResponse(bufio.NewReader(conn), &amp;http.Request{Method: "CONNECT"})
        if err != nil || resp.Status != HTTPConnected </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        err = errors.New("unexpected HTTP response: " + resp.Status)
                }</span>
                <span class="cov0" title="0">conn.Close()
                return nil, &amp;net.OpError{
                        Op:   "dial-http",
                        Net:  "tcp" + " " + address,
                        Addr: nil,
                        Err:  err,
                }</span>
        }
        <span class="cov5" title="4">t := &amp;httpConn{
                address: address,
                conn:    conn,
        }
        return t, nil</span>
}
func (t *httpConn) NoDelay(enable bool) <span class="cov5" title="4">{
        t.noDelay = enable
}</span>
func (t *httpConn) Multiplexing(enable bool) {<span class="cov5" title="4">
}</span>
func (t *httpConn) Handle(readChan chan []byte, writeChan chan []byte, stopChan chan bool, finishChan chan bool) <span class="cov5" title="4">{
        t.readChan = readChan
        t.writeChan = writeChan
        t.stopChan = stopChan
        t.finishChan = finishChan
        t.handle()
}</span>
func (t *httpConn) handle() <span class="cov5" title="4">{
        readChan := make(chan []byte, 1)
        writeChan := make(chan []byte, 1)
        finishChan := make(chan bool, 2)
        stopReadStreamChan := make(chan bool, 1)
        stopWriteStreamChan := make(chan bool, 1)
        go protocol.ReadStream(t.conn, readChan, stopReadStreamChan, finishChan)
        go protocol.WriteStream(t.conn, writeChan, stopWriteStreamChan, finishChan, t.noDelay)
        go func() </span><span class="cov5" title="4">{
                t.closed = false
                //logger.Traceln("TCPConn.handle start")
                for </span><span class="cov10" title="14">{
                        select </span>{
                        case v := &lt;-readChan:<span class="cov5" title="4">
                                func() </span><span class="cov5" title="4">{
                                        defer func() </span><span class="cov5" title="4">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov5" title="4">t.readChan &lt;- v</span>
                                }()
                        case v := &lt;-t.writeChan:<span class="cov7" title="6">
                                func() </span><span class="cov7" title="6">{
                                        defer func() </span><span class="cov7" title="6">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov7" title="6">writeChan &lt;- v</span>
                                }()
                        case stop := &lt;-finishChan:<span class="cov0" title="0">
                                if stop </span><span class="cov0" title="0">{
                                        stopReadStreamChan &lt;- true
                                        stopWriteStreamChan &lt;- true
                                        func() </span><span class="cov0" title="0">{
                                                defer func() </span><span class="cov0" title="0">{
                                                        if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                        }</span>
                                                }()
                                                <span class="cov0" title="0">t.finishChan &lt;- true</span>
                                        }()
                                        <span class="cov0" title="0">goto endfor</span>
                                }
                        case &lt;-t.stopChan:<span class="cov5" title="4">
                                stopReadStreamChan &lt;- true
                                stopWriteStreamChan &lt;- true
                                goto endfor</span>
                        }
                }
        endfor:
                <span class="cov5" title="4">close(readChan)
                close(writeChan)
                close(finishChan)
                close(stopReadStreamChan)
                close(stopWriteStreamChan)
                //logger.Traceln("TCPConn.handle end")
                t.closed = true</span>
        }()
}
func (t *httpConn) TickerFactor() int <span class="cov3" title="2">{
        return 300
}</span>
func (t *httpConn) BatchFactor() int <span class="cov5" title="4">{
        return 512
}</span>
func (t *httpConn) Retry() error <span class="cov0" title="0">{
        var err error
        conn, err := net.Dial("tcp", t.address)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">path := ""
        io.WriteString(conn, "CONNECT "+path+" HTTP/1.0\n\n")

        // Require successful HTTP response
        // before switching to RPC protocol.
        resp, err := http.ReadResponse(bufio.NewReader(conn), &amp;http.Request{Method: "CONNECT"})
        if err != nil || resp.Status != HTTPConnected </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        err = errors.New("unexpected HTTP response: " + resp.Status)
                }</span>
                <span class="cov0" title="0">conn.Close()
                return &amp;net.OpError{
                        Op:   "dial-http",
                        Net:  "tcp" + " " + t.address,
                        Addr: nil,
                        Err:  err,
                }</span>
        }
        <span class="cov0" title="0">t.conn = conn
        return nil</span>
}
func (t *httpConn) Close() error <span class="cov5" title="4">{
        return t.conn.Close()
}</span>

func (t *httpConn) Closed() bool <span class="cov0" title="0">{
        return t.closed
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package rpc

import (
        "bytes"
        "hslam.com/git/x/protocol"
        "io"
        "io/ioutil"
        "net/http"
        "net/url"
        "runtime"
        "time"
)

type http1Conn struct {
        conn         *http.Client
        address      string
        url          string
        CanWork      bool
        closed       bool
        multiplexing bool
}

func dialHTTP1(address string) (Conn, error) <span class="cov0" title="0">{
        u := url.URL{Scheme: "http", Host: address, Path: "/"}
        t := &amp;http1Conn{
                conn: &amp;http.Client{
                        Transport: &amp;http.Transport{
                                DisableKeepAlives: false,
                                MaxConnsPerHost:   1,
                        },
                },
                address: address,
                url:     u.String(),
        }
        return t, nil
}</span>
func (t *http1Conn) NoDelay(enable bool) {<span class="cov0" title="0">
}</span>
func (t *http1Conn) Multiplexing(enable bool) <span class="cov0" title="0">{
        t.multiplexing = enable
        if t.multiplexing </span><span class="cov0" title="0">{
                t.conn.Transport = &amp;http.Transport{
                        DisableKeepAlives:   false,
                        MaxConnsPerHost:     runtime.NumCPU(),
                        MaxIdleConnsPerHost: runtime.NumCPU(),
                }
        }</span> else<span class="cov0" title="0"> {
                t.conn.Transport = &amp;http.Transport{
                        DisableKeepAlives:   false,
                        MaxConnsPerHost:     1,
                        MaxIdleConnsPerHost: 1,
                }
        }</span>
}
func (t *http1Conn) Handle(readChan chan []byte, writeChan chan []byte, stopChan chan bool, finishChan chan bool) <span class="cov0" title="0">{
        go protocol.HandleSyncConn(t, readChan, writeChan, stopChan, 64)
}</span>
func (t *http1Conn) TickerFactor() int <span class="cov0" title="0">{
        return 100
}</span>
func (t *http1Conn) BatchFactor() int <span class="cov0" title="0">{
        return 512
}</span>
func (t *http1Conn) Retry() error <span class="cov0" title="0">{
        var Transport *http.Transport
        if t.multiplexing </span><span class="cov0" title="0">{
                Transport = &amp;http.Transport{
                        DisableKeepAlives:   false,
                        MaxConnsPerHost:     runtime.NumCPU(),
                        MaxIdleConnsPerHost: runtime.NumCPU(),
                }
        }</span> else<span class="cov0" title="0"> {
                Transport = &amp;http.Transport{
                        DisableKeepAlives:   false,
                        MaxConnsPerHost:     1,
                        MaxIdleConnsPerHost: 1,
                }
        }</span>
        <span class="cov0" title="0">if DefaultClientTimeout &gt; 0 </span><span class="cov0" title="0">{
                Transport.IdleConnTimeout = time.Duration(DefaultClientTimeout) * time.Millisecond
        }</span>
        <span class="cov0" title="0">t.conn = &amp;http.Client{
                Transport: Transport,
        }
        return nil</span>
}
func (t *http1Conn) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (t *http1Conn) Do(requestBody []byte) ([]byte, error) <span class="cov0" title="0">{
        var requestBodyReader io.Reader
        if requestBody != nil </span><span class="cov0" title="0">{
                requestBodyReader = bytes.NewReader(requestBody)
        }</span>
        <span class="cov0" title="0">req, _ := http.NewRequest("POST", t.url, requestBodyReader)
        resp, err := t.conn.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        return ioutil.ReadAll(resp.Body)</span>
}

func (t *http1Conn) Closed() bool <span class="cov0" title="0">{
        return t.closed
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package rpc

import (
        "hslam.com/git/x/protocol"
        "net"
)

type ipcConn struct {
        conn       *net.UnixConn
        address    string
        CanWork    bool
        readChan   chan []byte
        writeChan  chan []byte
        stopChan   chan bool
        finishChan chan bool
        closed     bool
        noDelay    bool
}

func dialIPC(address string) (Conn, error) <span class="cov6" title="7">{
        var addr *net.UnixAddr
        var err error
        if addr, err = net.ResolveUnixAddr("unix", address); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="7">conn, err := net.DialUnix("unix", nil, addr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov6" title="7">t := &amp;ipcConn{
                conn:    conn,
                address: address,
        }
        return t, nil</span>
}

func (t *ipcConn) Handle(readChan chan []byte, writeChan chan []byte, stopChan chan bool, finishChan chan bool) <span class="cov6" title="7">{
        t.readChan = readChan
        t.writeChan = writeChan
        t.stopChan = stopChan
        t.finishChan = finishChan
        t.handle()
}</span>
func (t *ipcConn) NoDelay(enable bool) <span class="cov6" title="7">{
        t.noDelay = enable
}</span>
func (t *ipcConn) Multiplexing(enable bool) {<span class="cov6" title="7">
}</span>
func (t *ipcConn) handle() <span class="cov6" title="7">{
        readChan := make(chan []byte, 1)
        writeChan := make(chan []byte, 1)
        finishChan := make(chan bool, 2)
        stopReadStreamChan := make(chan bool, 1)
        stopWriteStreamChan := make(chan bool, 1)
        go protocol.ReadStream(t.conn, readChan, stopReadStreamChan, finishChan)
        go protocol.WriteStream(t.conn, writeChan, stopWriteStreamChan, finishChan, t.noDelay)
        go func() </span><span class="cov6" title="7">{
                t.closed = false
                //logger.Traceln("TCPConn.handle start")
                for </span><span class="cov10" title="31">{
                        select </span>{
                        case v := &lt;-readChan:<span class="cov6" title="7">
                                func() </span><span class="cov6" title="7">{
                                        defer func() </span><span class="cov6" title="7">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov6" title="7">t.readChan &lt;- v</span>
                                }()
                        case v := &lt;-t.writeChan:<span class="cov8" title="17">
                                func() </span><span class="cov8" title="17">{
                                        defer func() </span><span class="cov8" title="17">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov8" title="17">writeChan &lt;- v</span>
                                }()
                        case stop := &lt;-finishChan:<span class="cov0" title="0">
                                if stop </span><span class="cov0" title="0">{
                                        stopReadStreamChan &lt;- true
                                        stopWriteStreamChan &lt;- true
                                        func() </span><span class="cov0" title="0">{
                                                defer func() </span><span class="cov0" title="0">{
                                                        if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                        }</span>
                                                }()
                                                <span class="cov0" title="0">t.finishChan &lt;- true</span>
                                        }()
                                        <span class="cov0" title="0">goto endfor</span>
                                }
                        case &lt;-t.stopChan:<span class="cov6" title="7">
                                stopReadStreamChan &lt;- true
                                stopWriteStreamChan &lt;- true
                                goto endfor</span>
                        }
                }
        endfor:
                <span class="cov6" title="7">close(readChan)
                close(writeChan)
                close(finishChan)
                close(stopReadStreamChan)
                close(stopWriteStreamChan)
                //logger.Traceln("TCPConn.handle end")
                t.closed = true</span>
        }()
}
func (t *ipcConn) TickerFactor() int <span class="cov0" title="0">{
        return 300
}</span>
func (t *ipcConn) BatchFactor() int <span class="cov0" title="0">{
        return 512
}</span>
func (t *ipcConn) Retry() error <span class="cov0" title="0">{
        var addr *net.UnixAddr
        var err error
        if addr, err = net.ResolveUnixAddr("unix", t.address); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">conn, err := net.DialUnix("unix", nil, addr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">t.conn = conn
        t.handle()
        //logger.Traceln("IPCConn.Retry")
        return nil</span>
}
func (t *ipcConn) Close() error <span class="cov6" title="7">{
        return t.conn.Close()
}</span>
func (t *ipcConn) Closed() bool <span class="cov0" title="0">{
        return t.closed
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package rpc

import (
        "context"
        "crypto/tls"
        "github.com/lucas-clemente/quic-go"
        "hslam.com/git/x/protocol"
)

type quicConn struct {
        conn       quic.Stream
        address    string
        CanWork    bool
        readChan   chan []byte
        writeChan  chan []byte
        stopChan   chan bool
        finishChan chan bool
        closed     bool
        noDelay    bool
}

func dialQUIC(address string) (Conn, error) <span class="cov5" title="4">{
        session, err := quic.DialAddr(address, &amp;tls.Config{InsecureSkipVerify: true, NextProtos: []string{"quic-rpc"}}, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov5" title="4">stream, err := session.OpenStreamSync(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov5" title="4">t := &amp;quicConn{
                conn:    stream,
                address: address,
        }
        return t, nil</span>
}
func (t *quicConn) NoDelay(enable bool) <span class="cov5" title="4">{
        t.noDelay = enable
}</span>
func (t *quicConn) Multiplexing(enable bool) {<span class="cov5" title="4">
}</span>
func (t *quicConn) Handle(readChan chan []byte, writeChan chan []byte, stopChan chan bool, finishChan chan bool) <span class="cov5" title="4">{
        t.readChan = readChan
        t.writeChan = writeChan
        t.stopChan = stopChan
        t.finishChan = finishChan
        t.handle()
}</span>
func (t *quicConn) handle() <span class="cov5" title="4">{
        readChan := make(chan []byte, 1)
        writeChan := make(chan []byte, 1)
        finishChan := make(chan bool, 2)
        stopReadStreamChan := make(chan bool, 1)
        stopWriteStreamChan := make(chan bool, 1)
        go protocol.ReadStream(t.conn, readChan, stopReadStreamChan, finishChan)
        go protocol.WriteStream(t.conn, writeChan, stopWriteStreamChan, finishChan, t.noDelay)
        go func() </span><span class="cov5" title="4">{
                t.closed = false
                for </span><span class="cov10" title="14">{
                        select </span>{
                        case v := &lt;-readChan:<span class="cov5" title="4">
                                func() </span><span class="cov5" title="4">{
                                        defer func() </span><span class="cov5" title="4">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov5" title="4">t.readChan &lt;- v</span>
                                }()
                        case v := &lt;-t.writeChan:<span class="cov7" title="6">
                                func() </span><span class="cov7" title="6">{
                                        defer func() </span><span class="cov7" title="6">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov7" title="6">writeChan &lt;- v</span>
                                }()
                        case stop := &lt;-finishChan:<span class="cov0" title="0">
                                if stop </span><span class="cov0" title="0">{
                                        stopReadStreamChan &lt;- true
                                        stopWriteStreamChan &lt;- true
                                        func() </span><span class="cov0" title="0">{
                                                defer func() </span><span class="cov0" title="0">{
                                                        if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                        }</span>
                                                }()
                                                <span class="cov0" title="0">t.finishChan &lt;- true</span>
                                        }()
                                        <span class="cov0" title="0">goto endfor</span>
                                }
                        case &lt;-t.stopChan:<span class="cov5" title="4">
                                stopReadStreamChan &lt;- true
                                stopWriteStreamChan &lt;- true
                                goto endfor</span>
                        }
                }
        endfor:
                <span class="cov5" title="4">close(readChan)
                close(writeChan)
                close(finishChan)
                close(stopReadStreamChan)
                close(stopWriteStreamChan)
                t.closed = true</span>
        }()
}

func (t *quicConn) TickerFactor() int <span class="cov3" title="2">{
        return 1000
}</span>
func (t *quicConn) BatchFactor() int <span class="cov5" title="4">{
        return 32
}</span>
func (t *quicConn) Retry() error <span class="cov0" title="0">{
        session, err := quic.DialAddr(t.address, &amp;tls.Config{InsecureSkipVerify: true}, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">stream, err := session.OpenStreamSync(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">t.conn = stream
        t.handle()
        return nil</span>
}
func (t *quicConn) Close() error <span class="cov5" title="4">{
        return t.conn.Close()
}</span>
func (t *quicConn) Closed() bool <span class="cov0" title="0">{
        return t.closed
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package rpc

import (
        "hslam.com/git/x/protocol"
        "net"
)

type tcpConn struct {
        conn       *net.TCPConn
        address    string
        CanWork    bool
        readChan   chan []byte
        writeChan  chan []byte
        stopChan   chan bool
        finishChan chan bool
        closed     bool
        noDelay    bool
}

func dialTCP(address string) (Conn, error) <span class="cov5" title="4">{
        tcpAddr, err := net.ResolveTCPAddr("tcp4", address)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov5" title="4">conn, err := net.DialTCP("tcp", nil, tcpAddr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov5" title="4">conn.SetNoDelay(true)
        t := &amp;tcpConn{
                conn:    conn,
                address: address,
        }
        return t, nil</span>
}

func (t *tcpConn) Handle(readChan chan []byte, writeChan chan []byte, stopChan chan bool, finishChan chan bool) <span class="cov5" title="4">{
        t.readChan = readChan
        t.writeChan = writeChan
        t.stopChan = stopChan
        t.finishChan = finishChan
        t.handle()
}</span>
func (t *tcpConn) NoDelay(enable bool) <span class="cov5" title="4">{
        t.noDelay = enable
}</span>
func (t *tcpConn) Multiplexing(enable bool) {<span class="cov5" title="4">
}</span>
func (t *tcpConn) handle() <span class="cov5" title="4">{
        readChan := make(chan []byte, 1)
        writeChan := make(chan []byte, 1)
        finishChan := make(chan bool, 2)
        stopReadStreamChan := make(chan bool, 1)
        stopWriteStreamChan := make(chan bool, 1)
        go protocol.ReadStream(t.conn, readChan, stopReadStreamChan, finishChan)
        go protocol.WriteStream(t.conn, writeChan, stopWriteStreamChan, finishChan, t.noDelay)
        go func() </span><span class="cov5" title="4">{
                t.closed = false
                //logger.Traceln("TCPConn.handle start")
                for </span><span class="cov10" title="14">{
                        select </span>{
                        case v := &lt;-readChan:<span class="cov5" title="4">
                                func() </span><span class="cov5" title="4">{
                                        defer func() </span><span class="cov5" title="4">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov5" title="4">t.readChan &lt;- v</span>
                                }()
                        case v := &lt;-t.writeChan:<span class="cov7" title="6">
                                func() </span><span class="cov7" title="6">{
                                        defer func() </span><span class="cov7" title="6">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov7" title="6">writeChan &lt;- v</span>
                                }()
                        case stop := &lt;-finishChan:<span class="cov3" title="2">
                                if stop </span><span class="cov3" title="2">{
                                        stopReadStreamChan &lt;- true
                                        stopWriteStreamChan &lt;- true
                                        func() </span><span class="cov3" title="2">{
                                                defer func() </span><span class="cov3" title="2">{
                                                        if err := recover(); err != nil </span>{<span class="cov3" title="2">
                                                        }</span>
                                                }()
                                                <span class="cov3" title="2">t.finishChan &lt;- true</span>
                                        }()
                                        <span class="cov3" title="2">goto endfor</span>
                                }
                        case &lt;-t.stopChan:<span class="cov3" title="2">
                                stopReadStreamChan &lt;- true
                                stopWriteStreamChan &lt;- true
                                goto endfor</span>
                        }
                }
        endfor:
                <span class="cov5" title="4">close(readChan)
                close(writeChan)
                close(finishChan)
                close(stopReadStreamChan)
                close(stopWriteStreamChan)
                //logger.Traceln("TCPConn.handle end")
                t.closed = true</span>
        }()
}
func (t *tcpConn) TickerFactor() int <span class="cov3" title="2">{
        return 300
}</span>
func (t *tcpConn) BatchFactor() int <span class="cov5" title="4">{
        return 512
}</span>
func (t *tcpConn) Retry() error <span class="cov0" title="0">{
        tcpAddr, err := net.ResolveTCPAddr("tcp4", t.address)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">conn, err := net.DialTCP("tcp", nil, tcpAddr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">t.conn = conn
        t.handle()
        //logger.Traceln("TCPConn.Retry")
        return nil</span>
}
func (t *tcpConn) Close() error <span class="cov5" title="4">{
        return t.conn.Close()
}</span>
func (t *tcpConn) Closed() bool <span class="cov0" title="0">{
        return t.closed
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package rpc

import (
        "hslam.com/git/x/protocol"
        "net"
)

type udpConn struct {
        conn       net.Conn
        address    string
        CanWork    bool
        readChan   chan []byte
        writeChan  chan []byte
        stopChan   chan bool
        finishChan chan bool
        closed     bool
}

func dialUDP(address string) (Conn, error) <span class="cov5" title="4">{
        conn, err := net.Dial(UDP, address)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov5" title="4">t := &amp;udpConn{
                conn:    conn,
                address: address,
        }
        return t, nil</span>
}
func (t *udpConn) NoDelay(enable bool) {<span class="cov5" title="4">
}</span>
func (t *udpConn) Multiplexing(enable bool) {<span class="cov5" title="4">
}</span>
func (t *udpConn) Handle(readChan chan []byte, writeChan chan []byte, stopChan chan bool, finishChan chan bool) <span class="cov5" title="4">{
        t.readChan = readChan
        t.writeChan = writeChan
        t.stopChan = stopChan
        t.finishChan = finishChan
        t.handle()
}</span>
func (t *udpConn) handle() <span class="cov5" title="4">{
        readChan := make(chan []byte, 1)
        writeChan := make(chan []byte, 1)
        finishChan := make(chan bool, 1)
        stopChan := make(chan bool, 1)
        go protocol.HandleMessage(t.conn, readChan, writeChan, stopChan, finishChan)
        go func() </span><span class="cov5" title="4">{
                t.closed = false
                for </span><span class="cov10" title="14">{
                        select </span>{
                        case v := &lt;-readChan:<span class="cov5" title="4">
                                func() </span><span class="cov5" title="4">{
                                        defer func() </span><span class="cov5" title="4">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov5" title="4">t.readChan &lt;- v</span>
                                }()
                        case v := &lt;-t.writeChan:<span class="cov7" title="6">
                                func() </span><span class="cov7" title="6">{
                                        defer func() </span><span class="cov7" title="6">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov7" title="6">writeChan &lt;- v</span>
                                }()
                        case &lt;-t.stopChan:<span class="cov5" title="4">
                                func() </span><span class="cov5" title="4">{
                                        defer func() </span><span class="cov5" title="4">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov5" title="4">stopChan &lt;- true</span>
                                }()
                                <span class="cov5" title="4">goto endfor</span>
                        case &lt;-finishChan:<span class="cov0" title="0">
                                func() </span><span class="cov0" title="0">{
                                        defer func() </span><span class="cov0" title="0">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov0" title="0">t.finishChan &lt;- true</span>
                                }()
                                <span class="cov0" title="0">goto endfor</span>
                        }
                }
        endfor:
                <span class="cov5" title="4">close(readChan)
                close(writeChan)
                close(finishChan)
                close(stopChan)
                t.closed = true</span>
        }()
}
func (t *udpConn) TickerFactor() int <span class="cov3" title="2">{
        return 1
}</span>
func (t *udpConn) BatchFactor() int <span class="cov5" title="4">{
        return 1
}</span>
func (t *udpConn) Retry() error <span class="cov0" title="0">{
        conn, err := net.Dial(UDP, t.address)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">t.conn = conn
        t.handle()
        return nil</span>
}
func (t *udpConn) Close() error <span class="cov5" title="4">{
        return t.conn.Close()
}</span>

func (t *udpConn) Closed() bool <span class="cov0" title="0">{
        return t.closed
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package rpc

import (
        "github.com/gorilla/websocket"
        "hslam.com/git/x/protocol"
        "net/url"
)

type wsConn struct {
        conn       *protocol.MsgConn
        address    string
        CanWork    bool
        readChan   chan []byte
        writeChan  chan []byte
        stopChan   chan bool
        finishChan chan bool
        closed     bool
}

func dialWS(address string) (Conn, error) <span class="cov5" title="4">{
        u := url.URL{Scheme: "ws", Host: address, Path: "/"}
        c, _, err := websocket.DefaultDialer.Dial(u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov5" title="4">t := &amp;wsConn{
                conn:    &amp;protocol.MsgConn{MessageConn: &amp;websocketConn{c}},
                address: address,
        }
        t.CanWork = true
        return t, nil</span>
}
func (t *wsConn) NoDelay(enable bool) {<span class="cov5" title="4">
}</span>
func (t *wsConn) Multiplexing(enable bool) {<span class="cov5" title="4">
}</span>
func (t *wsConn) Handle(readChan chan []byte, writeChan chan []byte, stopChan chan bool, finishChan chan bool) <span class="cov5" title="4">{
        t.readChan = readChan
        t.writeChan = writeChan
        t.stopChan = stopChan
        t.finishChan = finishChan
        t.handle()
}</span>
func (t *wsConn) handle() <span class="cov5" title="4">{
        readChan := make(chan []byte, 1)
        writeChan := make(chan []byte, 1)
        finishChan := make(chan bool, 2)
        stopReadConnChan := make(chan bool, 1)
        stopWriteConnChan := make(chan bool, 1)
        go protocol.ReadConn(t.conn, readChan, stopReadConnChan, finishChan)
        go protocol.WriteConn(t.conn, writeChan, stopWriteConnChan, finishChan)
        go func() </span><span class="cov5" title="4">{
                t.closed = false
                for </span><span class="cov10" title="17">{
                        select </span>{
                        case v := &lt;-readChan:<span class="cov5" title="4">
                                func() </span><span class="cov5" title="4">{
                                        defer func() </span><span class="cov5" title="4">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov5" title="4">t.readChan &lt;- v</span>
                                }()
                        case v := &lt;-t.writeChan:<span class="cov7" title="9">
                                func() </span><span class="cov7" title="9">{
                                        defer func() </span><span class="cov7" title="9">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov7" title="9">writeChan &lt;- v</span>
                                }()
                        case stop := &lt;-finishChan:<span class="cov4" title="3">
                                if stop </span><span class="cov4" title="3">{
                                        stopReadConnChan &lt;- true
                                        stopWriteConnChan &lt;- true
                                        func() </span><span class="cov4" title="3">{
                                                defer func() </span><span class="cov4" title="3">{
                                                        if err := recover(); err != nil </span>{<span class="cov4" title="3">
                                                        }</span>
                                                }()
                                                <span class="cov4" title="3">t.finishChan &lt;- true</span>
                                        }()
                                        <span class="cov4" title="3">goto endfor</span>
                                }
                        case &lt;-t.stopChan:<span class="cov1" title="1">
                                stopReadConnChan &lt;- true
                                stopWriteConnChan &lt;- true
                                goto endfor</span>
                        }
                }
        endfor:
                <span class="cov5" title="4">close(readChan)
                close(writeChan)
                close(finishChan)
                close(stopReadConnChan)
                close(stopWriteConnChan)
                t.closed = true</span>
        }()
}
func (t *wsConn) TickerFactor() int <span class="cov3" title="2">{
        return 100
}</span>
func (t *wsConn) BatchFactor() int <span class="cov5" title="4">{
        return 512
}</span>
func (t *wsConn) Retry() error <span class="cov0" title="0">{
        u := url.URL{Scheme: "ws", Host: t.address, Path: "/"}
        c, _, err := websocket.DefaultDialer.Dial(u.String(), nil)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">t.conn = &amp;protocol.MsgConn{MessageConn: &amp;websocketConn{c}}
        t.handle()
        return nil</span>
}
func (t *wsConn) Close() error <span class="cov5" title="4">{
        return t.conn.Close()
}</span>
func (t *wsConn) Closed() bool <span class="cov0" title="0">{
        return t.closed
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package rpc

import (
        "sync/atomic"
)

type count struct {
        v int64
}

func (c *count) add(delta int64) int64 <span class="cov0" title="0">{
        return atomic.AddInt64(&amp;c.v, delta)
}</span>

func (c *count) load() int64 <span class="cov10" title="10">{
        return atomic.LoadInt64(&amp;c.v)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package rpc

import (
        "hslam.com/git/x/protocol"
        "math/rand"
        "sync"
        "time"
)

type multiplex struct {
        mu             sync.RWMutex
        client         *client
        requestChan    chan *ioRequest
        cache          map[uint32]*ioRequest
        noResponseChan chan *ioRequest
        idChan         chan uint32
        readChan       chan []byte
        writeChan      chan []byte
        maxRequests    int
        stop           bool
        closeChan      chan bool
}

func newMultiplex(c *client, maxRequests int, readChan chan []byte, writeChan chan []byte) *multiplex <span class="cov10" title="17">{
        m := &amp;multiplex{
                client:         c,
                requestChan:    make(chan *ioRequest, maxRequests),
                cache:          make(map[uint32]*ioRequest, maxRequests*2),
                noResponseChan: make(chan *ioRequest, maxRequests*2),
                idChan:         make(chan uint32, maxRequests),
                readChan:       readChan,
                writeChan:      writeChan,
                maxRequests:    maxRequests,
                closeChan:      make(chan bool, 1),
        }
        go m.run()
        return m
}</span>
func (c *multiplex) NewRequest(priority uint8, data []byte, noResponse bool, cbChan chan []byte) *ioRequest <span class="cov10" title="17">{
        r := &amp;ioRequest{
                priority:   priority,
                data:       data,
                noResponse: noResponse,
                cbChan:     cbChan,
                startTime:  time.Now(),
        }
        return r
}</span>
func (c *multiplex) RequestChan() requestChan <span class="cov10" title="17">{
        return c.requestChan
}</span>
func (c *multiplex) ResetMaxRequests(max int) <span class="cov0" title="0">{
        c.maxRequests = max
}</span>
func (c *multiplex) Reset(readChan chan []byte, writeChan chan []byte) <span class="cov0" title="0">{
        c.readChan = readChan
        c.writeChan = writeChan
}</span>
func (c *multiplex) run() <span class="cov10" title="17">{
        r := rand.New(rand.NewSource(time.Now().UnixNano()))
        var startbit = uint(r.Intn(13))
        id := uint32(r.Int31n(int32(1 &lt;&lt; startbit)))
        maxID := uint32(1&lt;&lt;32 - 1)
        go func() </span><span class="cov10" title="17">{
                for mr := range c.requestChan </span><span class="cov10" title="17">{
                        func() </span><span class="cov10" title="17">{
                                c.mu.Lock()
                                defer c.mu.Unlock()
                                func() </span><span class="cov10" title="17">{
                                        defer func() </span><span class="cov10" title="17">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                        }()
                                        <span class="cov10" title="17">for </span><span class="cov10" title="17">{
                                                id = (id + 1) % maxID
                                                if !c.IsExisted(id) </span><span class="cov10" title="17">{
                                                        break</span>
                                                }
                                        }
                                        <span class="cov10" title="17">mr.id = id
                                        frameBytes := protocol.PacketFrame(mr.priority, id, mr.data)
                                        c.writeChan &lt;- frameBytes
                                        if mr.noResponse == false </span><span class="cov10" title="17">{
                                                c.idChan &lt;- id
                                                c.Set(id, mr)
                                        }</span> else<span class="cov0" title="0"> {
                                                if len(c.noResponseChan) &gt;= c.maxRequests </span><span class="cov0" title="0">{
                                                        &lt;-c.noResponseChan
                                                }</span>
                                                <span class="cov0" title="0">c.noResponseChan &lt;- mr
                                                mr.cbChan &lt;- []byte("0")</span>
                                        }
                                }()
                        }()
                }
        }()
        <span class="cov10" title="17">go func() </span><span class="cov10" title="17">{
                for b := range c.readChan </span><span class="cov10" title="17">{
                        func() </span><span class="cov10" title="17">{
                                c.mu.Lock()
                                defer c.mu.Unlock()
                                _, ID, body, err := protocol.UnpackFrame(b)
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov10" title="17">mr := c.Get(ID)
                                if mr != nil </span><span class="cov10" title="17">{
                                        mr.cbChan &lt;- body
                                }</span>
                                <span class="cov10" title="17">c.Delete(ID)
                                if len(c.idChan) &gt; 0 </span><span class="cov10" title="17">{
                                        &lt;-c.idChan
                                }</span>
                        }()
                }
        }()
        <span class="cov10" title="17">ticker := time.NewTicker(time.Second)
        for </span><span class="cov10" title="17">{
                select </span>{
                case &lt;-c.closeChan:<span class="cov10" title="17">
                        close(c.closeChan)
                        ticker.Stop()
                        ticker = nil
                        goto endfor</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.deleteOld()</span>
                }
        }
endfor:
}
func (c *multiplex) deleteOld() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if len(c.cache) &gt; 0 </span><span class="cov0" title="0">{
                for _, mr := range c.cache </span><span class="cov0" title="0">{
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                        }</span>
                                }()
                                <span class="cov0" title="0">if c.client.timeout &gt; 0 </span><span class="cov0" title="0">{
                                        if mr.startTime.Add(time.Millisecond * time.Duration(c.client.timeout)).Before(time.Now()) </span><span class="cov0" title="0">{
                                                c.Delete(mr.id)
                                                if len(c.idChan) &gt; 0 </span><span class="cov0" title="0">{
                                                        &lt;-c.idChan
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        if mr.startTime.Add(time.Minute * 5).Before(time.Now()) </span><span class="cov0" title="0">{
                                                c.Delete(mr.id)
                                                if len(c.idChan) &gt; 0 </span><span class="cov0" title="0">{
                                                        &lt;-c.idChan
                                                }</span>
                                        }
                                }
                        }()
                }
        }
}
func (c *multiplex) Retry() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.idChan = make(chan uint32, c.maxRequests*2)
        if len(c.readChan) &gt; 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(c.readChan); i++ </span><span class="cov0" title="0">{
                        &lt;-c.readChan
                }</span>
        }
        <span class="cov0" title="0">if len(c.writeChan) &gt; 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(c.writeChan); i++ </span><span class="cov0" title="0">{
                        &lt;-c.writeChan
                }</span>
        }
        <span class="cov0" title="0">if len(c.noResponseChan) &gt; 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(c.noResponseChan); i++ </span><span class="cov0" title="0">{
                        mr := &lt;-c.noResponseChan
                        c.idChan &lt;- mr.id
                        frameBytes := protocol.PacketFrame(mr.priority, mr.id, mr.data)
                        c.writeChan &lt;- frameBytes
                        c.noResponseChan &lt;- mr
                }</span>
        }
        <span class="cov0" title="0">if len(c.cache) &gt; 0 </span><span class="cov0" title="0">{
                for _, mr := range c.cache </span><span class="cov0" title="0">{
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                        }</span>
                                }()
                                <span class="cov0" title="0">c.idChan &lt;- mr.id
                                frameBytes := protocol.PacketFrame(mr.priority, mr.id, mr.data)
                                c.writeChan &lt;- frameBytes</span>
                        }()
                }
        }
}

func (c *multiplex) IsExisted(id uint32) bool <span class="cov10" title="17">{
        if _, ok := c.cache[id]; !ok </span><span class="cov10" title="17">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
func (c *multiplex) Set(id uint32, multiplexRequest *ioRequest) <span class="cov10" title="17">{
        c.cache[id] = multiplexRequest
}</span>
func (c *multiplex) Get(id uint32) *ioRequest <span class="cov10" title="17">{
        if _, ok := c.cache[id]; !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov10" title="17">return c.cache[id]</span>
}
func (c *multiplex) Delete(id uint32) <span class="cov10" title="17">{
        if _, ok := c.cache[id]; !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="17">delete(c.cache, id)</span>
}
func (c *multiplex) Length() int <span class="cov0" title="0">{
        return len(c.cache)
}</span>
func (c *multiplex) Close() <span class="cov10" title="17">{
        close(c.requestChan)
        close(c.noResponseChan)
        close(c.idChan)
        c.readChan = nil
        c.writeChan = nil
        c.client = nil
        c.cache = nil
        c.closeChan &lt;- true
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package rpc

import (
        "sync"
)

type pipeline struct {
        retryMu        sync.RWMutex
        client         *client
        requestChan    requestChan
        actionChan     requestChan
        noResponseChan requestChan
        readChan       chan []byte
        writeChan      chan []byte
        maxRequests    int
        closeChan      chan bool
}

func newPipeline(maxRequests int, readChan chan []byte, writeChan chan []byte) *pipeline <span class="cov7" title="10">{
        p := &amp;pipeline{
                requestChan:    make(requestChan, maxRequests),
                actionChan:     make(requestChan, maxRequests*2),
                noResponseChan: make(requestChan, maxRequests*2),
                readChan:       readChan,
                writeChan:      writeChan,
                maxRequests:    maxRequests,
                closeChan:      make(chan bool, 1),
        }
        go p.run()
        return p
}</span>
func (c *pipeline) NewRequest(priority uint8, data []byte, noResponse bool, cbChan chan []byte) *ioRequest <span class="cov7" title="10">{
        r := &amp;ioRequest{
                priority:   priority,
                data:       data,
                noResponse: noResponse,
                cbChan:     cbChan,
        }
        return r
}</span>
func (c *pipeline) RequestChan() requestChan <span class="cov7" title="10">{
        return c.requestChan
}</span>
func (c *pipeline) ResetMaxRequests(max int) <span class="cov0" title="0">{
        c.maxRequests = max
}</span>
func (c *pipeline) Reset(readChan chan []byte, writeChan chan []byte) <span class="cov0" title="0">{
        c.readChan = readChan
        c.writeChan = writeChan
}</span>
func (c *pipeline) run() <span class="cov7" title="10">{
        go func() </span><span class="cov7" title="10">{
                for cr := range c.requestChan </span><span class="cov7" title="10">{
                        func() </span><span class="cov7" title="10">{
                                c.retryMu.RLock()
                                defer c.retryMu.RUnlock()
                                func() </span><span class="cov7" title="10">{
                                        defer func() </span><span class="cov7" title="10">{
                                                if err := recover(); err != nil </span><span class="cov0" title="0">{
                                                        logger.Errorln("v.reply err", err)
                                                }</span>
                                        }()
                                        <span class="cov7" title="10">c.writeChan &lt;- cr.data
                                        if cr.noResponse == false </span><span class="cov7" title="10">{
                                                if len(c.actionChan) &lt;= c.maxRequests </span><span class="cov7" title="10">{
                                                        c.actionChan &lt;- cr
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                if len(c.noResponseChan) &gt;= c.maxRequests </span><span class="cov0" title="0">{
                                                        &lt;-c.noResponseChan
                                                }</span>
                                                <span class="cov0" title="0">c.noResponseChan &lt;- cr
                                                cr.cbChan &lt;- []byte("0")</span>
                                        }
                                }()
                        }()
                }
        }()
        <span class="cov7" title="10">for </span><span class="cov10" title="20">{
                select </span>{
                case &lt;-c.closeChan:<span class="cov7" title="10">
                        close(c.closeChan)
                        goto endfor</span>
                case b := &lt;-c.readChan:<span class="cov7" title="10">
                        func() </span><span class="cov7" title="10">{
                                c.retryMu.RLock()
                                defer c.retryMu.RUnlock()
                                cr := &lt;-c.actionChan
                                cr.cbChan &lt;- b
                        }</span>()
                }
        }
endfor:
}
func (c *pipeline) Retry() <span class="cov0" title="0">{
        c.retryMu.Lock()
        defer c.retryMu.Unlock()
        if len(c.readChan) &gt; 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(c.readChan); i++ </span><span class="cov0" title="0">{
                        &lt;-c.readChan
                }</span>
        }
        <span class="cov0" title="0">if len(c.writeChan) &gt; 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(c.writeChan); i++ </span><span class="cov0" title="0">{
                        &lt;-c.writeChan
                }</span>
        }
        <span class="cov0" title="0">if len(c.noResponseChan) &gt; 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(c.noResponseChan); i++ </span><span class="cov0" title="0">{
                        cr := &lt;-c.noResponseChan
                        c.writeChan &lt;- cr.data
                        c.noResponseChan &lt;- cr
                }</span>
        }
        <span class="cov0" title="0">if len(c.actionChan) &gt; 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(c.actionChan); i++ </span><span class="cov0" title="0">{
                        cr := &lt;-c.actionChan
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                                logger.Errorln("Pipeline.retry", err)
                                        }</span>
                                }()
                                <span class="cov0" title="0">c.writeChan &lt;- cr.data
                                if cr.noResponse == false </span><span class="cov0" title="0">{
                                        c.actionChan &lt;- cr
                                }</span>
                        }()

                }
        }
}
func (c *pipeline) Close() <span class="cov7" title="10">{
        close(c.requestChan)
        close(c.actionChan)
        close(c.noResponseChan)
        c.readChan = nil
        c.writeChan = nil
        c.client = nil
        c.closeChan &lt;- true
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package rpc

import (
        "errors"
)

//Listener defines the interface of listener.
type Listener interface {
        Serve() error
        Addr() string
        Close() error
}

// Listen announces on the local network address.
// The network must be "ipc", "tcp", "udp", "quic", "ws", "http" or "http1".
func Listen(network, address string, server *Server) (Listener, error) <span class="cov10" title="27">{
        logger.Noticef("network - %s", network)
        logger.Noticef("listening on %s", address)
        switch network </span>{
        case IPC:<span class="cov6" title="7">
                return listenIPC(address, server)</span>
        case TCP:<span class="cov4" title="4">
                return listenTCP(address, server)</span>
        case UDP:<span class="cov4" title="4">
                return listenUDP(address, server)</span>
        case QUIC:<span class="cov4" title="4">
                return listenQUIC(address, server)</span>
        case WS:<span class="cov4" title="4">
                return listenWS(address, server)</span>
        case HTTP:<span class="cov4" title="4">
                return listenHTTP(address, server)</span>
        case HTTP1:<span class="cov0" title="0">
                return listenHTTP(address, server)</span>
        }
        <span class="cov0" title="0">return nil, errors.New("this network is not suported")</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package rpc

import (
        "hslam.com/git/x/protocol"
        "io"
        "io/ioutil"
        "net/http"
)

type httpListener struct {
        server     *Server
        httpServer *http.Server
        address    string
        maxConnNum int
        connNum    int
}

func listenHTTP(address string, server *Server) (Listener, error) <span class="cov7" title="4">{
        httpServer := &amp;http.Server{
                Addr: address,
        }
        listener := &amp;httpListener{address: address, server: server, httpServer: httpServer, maxConnNum: DefaultMaxConnNum * server.asyncMax}
        return listener, nil
}</span>

func (l *httpListener) Serve() error <span class="cov7" title="4">{
        logger.Noticef("%s\n", "waiting for clients")
        h := new(handler)
        h.server = l.server
        h.workerChan = make(chan bool, l.maxConnNum)
        h.connChange = make(chan int)
        go func() </span><span class="cov7" title="4">{
                for c := range h.connChange </span><span class="cov10" title="8">{
                        l.connNum += c
                }</span>
        }()
        <span class="cov7" title="4">l.httpServer.Handler = h
        err := l.httpServer.ListenAndServe()
        if err != nil </span><span class="cov7" title="4">{
                if stringsContains(err.Error(), "http: Server closed") </span><span class="cov7" title="4">{
                        return nil
                }</span>
                <span class="cov0" title="0">logger.Errorf("fatal error: %s", err)
                return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (l *httpListener) Addr() string <span class="cov0" title="0">{
        return l.address
}</span>
func (l *httpListener) Close() error <span class="cov7" title="4">{
        return l.httpServer.Close()
}</span>

type handler struct {
        server     *Server
        workerChan chan bool
        connChange chan int
}

func (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov7" title="4">{
        w.Header().Set("Access-Control-Allow-Origin", "*")
        var RemoteAddr = r.RemoteAddr
        if r.Method == "POST" </span><span class="cov0" title="0">{
                data, err := ioutil.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">h.workerChan &lt;- true
                func() </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                }</span>
                                <span class="cov0" title="0">&lt;-h.workerChan</span>
                        }()
                        <span class="cov0" title="0">h.connChange &lt;- 1
                        defer func() </span><span class="cov0" title="0">{ h.connChange &lt;- -1 }</span>()
                        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ logger.Noticef("client %s exiting\n", RemoteAddr) }</span>()
                        <span class="cov0" title="0">logger.Noticef("client %s comming\n", RemoteAddr)
                        h.Serve(w, data)</span>
                }()
        } else<span class="cov7" title="4"> if r.Method == "CONNECT" </span><span class="cov7" title="4">{
                conn, _, err := w.(http.Hijacker).Hijack()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov7" title="4">io.WriteString(conn, "HTTP/1.1 "+HTTPConnected+"\n\n")
                func() </span><span class="cov7" title="4">{
                        defer func() </span><span class="cov7" title="4">{
                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                }</span>
                                <span class="cov7" title="4">&lt;-h.workerChan</span>
                        }()
                        <span class="cov7" title="4">h.connChange &lt;- 1
                        defer func() </span><span class="cov7" title="4">{ h.connChange &lt;- -1 }</span>()
                        <span class="cov7" title="4">defer func() </span><span class="cov7" title="4">{ logger.Infof("client %s exiting\n", conn.RemoteAddr()) }</span>()
                        <span class="cov7" title="4">logger.Infof("client %s comming\n", conn.RemoteAddr())
                        h.server.ServeConn(conn)</span>
                }()
        } else<span class="cov0" title="0"> {
                w.Header().Set("Content-Type", "text/plain; charset=utf-8")
                w.WriteHeader(http.StatusMethodNotAllowed)
                io.WriteString(w, "405 must CONNECT or POST\n")
        }</span>
}

func (h *handler) Serve(w io.Writer, data []byte) error <span class="cov0" title="0">{
        if h.server.multiplexing </span><span class="cov0" title="0">{
                priority, id, body, err := protocol.UnpackFrame(data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_, resBytes := h.server.Serve(body)
                if resBytes != nil </span><span class="cov0" title="0">{
                        frameBytes := protocol.PacketFrame(priority, id, resBytes)
                        _, err := w.Write(frameBytes)
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                _, resBytes := h.server.Serve(data)
                if resBytes != nil </span><span class="cov0" title="0">{
                        _, err := w.Write(resBytes)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return ErrConnExit</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package rpc

import (
        "net"
        "os"
)

type ipcListener struct {
        server      *Server
        address     string
        netListener net.Listener
        maxConnNum  int
        connNum     int
}

func listenIPC(address string, server *Server) (Listener, error) <span class="cov7" title="7">{
        os.Remove(address)
        var addr *net.UnixAddr
        var err error
        if addr, err = net.ResolveUnixAddr("unix", address); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="7">lis, err := net.ListenUnix("unix", addr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov7" title="7">listener := &amp;ipcListener{address: address, netListener: lis, server: server, maxConnNum: DefaultMaxConnNum}
        return listener, nil</span>
}
func (l *ipcListener) Serve() error <span class="cov7" title="7">{
        logger.Noticef("%s\n", "waiting for clients")
        workerChan := make(chan bool, l.maxConnNum)
        connChange := make(chan int)
        go func() </span><span class="cov7" title="7">{
                for c := range connChange </span><span class="cov10" title="14">{
                        l.connNum += c
                }</span>
        }()
        <span class="cov7" title="7">for </span><span class="cov10" title="14">{
                conn, err := l.netListener.Accept()
                if err != nil </span><span class="cov7" title="7">{
                        if stringsContains(err.Error(), "use of closed network connection") </span><span class="cov7" title="7">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">logger.Warnf("Accept: %s\n", err)
                        continue</span>
                }
                <span class="cov7" title="7">workerChan &lt;- true
                go func() </span><span class="cov7" title="7">{
                        defer func() </span><span class="cov7" title="7">{
                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                }</span>
                                <span class="cov7" title="7">&lt;-workerChan</span>
                        }()
                        <span class="cov7" title="7">connChange &lt;- 1
                        defer func() </span><span class="cov7" title="7">{ connChange &lt;- -1 }</span>()
                        <span class="cov7" title="7">defer func() </span><span class="cov7" title="7">{ logger.Infof("client %s exiting\n", conn.RemoteAddr()) }</span>()
                        <span class="cov7" title="7">logger.Infof("client %s comming\n", conn.RemoteAddr())
                        l.server.ServeConn(conn)</span>
                }()
        }
        <span class="cov0" title="0">return nil</span>
}
func (l *ipcListener) Addr() string <span class="cov0" title="0">{
        return l.address
}</span>
func (l *ipcListener) Close() error <span class="cov7" title="7">{
        return l.netListener.Close()
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package rpc

import (
        "context"
        "github.com/lucas-clemente/quic-go"
)

type quicListener struct {
        server       *Server
        address      string
        quicListener quic.Listener
        maxConnNum   int
        connNum      int
}

func listenQUIC(address string, server *Server) (Listener, error) <span class="cov7" title="4">{
        l, err := quic.ListenAddr(address, generateQuicTLSConfig(), nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov7" title="4">listener := &amp;quicListener{address: address, quicListener: l, server: server, maxConnNum: DefaultMaxConnNum}
        return listener, nil</span>
}
func (l *quicListener) Serve() error <span class="cov7" title="4">{
        logger.Noticef("%s\n", "waiting for clients")
        workerChan := make(chan bool, l.maxConnNum)
        connChange := make(chan int)
        go func() </span><span class="cov7" title="4">{
                for c := range connChange </span><span class="cov10" title="8">{
                        l.connNum += c
                }</span>
        }()
        <span class="cov7" title="4">for </span><span class="cov10" title="8">{
                sess, err := l.quicListener.Accept(context.Background())
                if err != nil </span><span class="cov7" title="4">{
                        if stringsContains(err.Error(), "server closed") </span><span class="cov7" title="4">{
                                break</span>
                        }
                        <span class="cov0" title="0">logger.Warnf("Accept: %s\n", err)
                        continue</span>
                } else<span class="cov7" title="4"> {
                        workerChan &lt;- true
                        go func() </span><span class="cov7" title="4">{
                                defer func() </span><span class="cov7" title="4">{
                                        if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                        }</span>
                                        <span class="cov7" title="4">&lt;-workerChan</span>
                                }()
                                <span class="cov7" title="4">connChange &lt;- 1
                                defer func() </span><span class="cov7" title="4">{ connChange &lt;- -1 }</span>()
                                <span class="cov7" title="4">defer func() </span><span class="cov7" title="4">{ logger.Infof("client %s exiting\n", sess.RemoteAddr()) }</span>()
                                <span class="cov7" title="4">logger.Infof("client %s comming\n", sess.RemoteAddr())
                                stream, err := sess.AcceptStream(context.Background())
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorln(err)
                                        return
                                }</span>
                                <span class="cov7" title="4">l.server.ServeConn(stream)</span>
                        }()
                }
        }
        <span class="cov7" title="4">return nil</span>
}
func (l *quicListener) Addr() string <span class="cov0" title="0">{
        return l.address
}</span>
func (l *quicListener) Close() error <span class="cov7" title="4">{
        return l.quicListener.Close()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package rpc

import (
        "net"
)

type tcpListener struct {
        server      *Server
        address     string
        netListener net.Listener
        maxConnNum  int
        connNum     int
}

func listenTCP(address string, server *Server) (Listener, error) <span class="cov7" title="4">{
        lis, err := net.Listen("tcp", address)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov7" title="4">listener := &amp;tcpListener{address: address, netListener: lis, server: server, maxConnNum: DefaultMaxConnNum}
        return listener, nil</span>
}
func (l *tcpListener) Serve() error <span class="cov7" title="4">{
        logger.Noticef("%s\n", "waiting for clients")
        workerChan := make(chan bool, l.maxConnNum)
        connChange := make(chan int)
        go func() </span><span class="cov7" title="4">{
                for c := range connChange </span><span class="cov10" title="8">{
                        l.connNum += c
                }</span>
        }()
        <span class="cov7" title="4">for </span><span class="cov10" title="8">{
                conn, err := l.netListener.Accept()
                if err != nil </span><span class="cov7" title="4">{
                        if stringsContains(err.Error(), "use of closed network connection") </span><span class="cov7" title="4">{
                                break</span>
                        }
                        <span class="cov0" title="0">logger.Warnf("Accept: %s\n", err)
                        continue</span>
                }
                <span class="cov7" title="4">workerChan &lt;- true
                go func() </span><span class="cov7" title="4">{
                        defer func() </span><span class="cov7" title="4">{
                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                }</span>
                                <span class="cov7" title="4">&lt;-workerChan</span>
                        }()
                        <span class="cov7" title="4">connChange &lt;- 1
                        defer func() </span><span class="cov7" title="4">{ connChange &lt;- -1 }</span>()
                        <span class="cov7" title="4">defer func() </span><span class="cov7" title="4">{ logger.Infof("client %s exiting\n", conn.RemoteAddr()) }</span>()
                        <span class="cov7" title="4">logger.Infof("client %s comming\n", conn.RemoteAddr())
                        l.server.ServeConn(conn)</span>
                }()
        }
        <span class="cov7" title="4">return nil</span>
}
func (l *tcpListener) Addr() string <span class="cov0" title="0">{
        return l.address
}</span>
func (l *tcpListener) Close() error <span class="cov7" title="4">{
        return l.netListener.Close()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package rpc

import (
        "hslam.com/git/x/protocol"
        "net"
)

type udpListener struct {
        server     *Server
        address    string
        netUDPConn *net.UDPConn
        maxConnNum int
        connNum    int
}

func listenUDP(address string, server *Server) (Listener, error) <span class="cov7" title="4">{
        addr, err := net.ResolveUDPAddr("udp", address)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov7" title="4">conn, err := net.ListenUDP("udp", addr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("fatal error: %s", err)
                return nil, err
        }</span>
        <span class="cov7" title="4">listener := &amp;udpListener{address: address, netUDPConn: conn, server: server, maxConnNum: DefaultMaxConnNum * server.asyncMax}
        return listener, nil</span>
}

func (l *udpListener) Serve() error <span class="cov7" title="4">{
        logger.Noticef("%s\n", "waiting for clients")
        workerChan := make(chan bool, l.maxConnNum)
        connChange := make(chan int)
        go func() </span><span class="cov7" title="4">{
                for c := range connChange </span><span class="cov10" title="8">{
                        l.connNum += c
                }</span>
        }()
        <span class="cov7" title="4">readChan := make(chan *protocol.UDPMsg, l.maxConnNum)
        writeChan := make(chan *protocol.UDPMsg, l.maxConnNum)
        go protocol.ReadUDPConn(l.netUDPConn, readChan)
        go protocol.WriteUDPConn(l.netUDPConn, writeChan)
        for </span><span class="cov10" title="8">{
                select </span>{
                case udpMsg := &lt;-readChan:<span class="cov7" title="4">
                        workerChan &lt;- true
                        go func() </span><span class="cov7" title="4">{
                                defer func() </span><span class="cov7" title="4">{
                                        if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                        }</span>
                                        <span class="cov7" title="4">&lt;-workerChan</span>
                                }()
                                <span class="cov7" title="4">connChange &lt;- 1
                                var RemoteAddr = udpMsg.RemoteAddr.String()
                                logger.Noticef("client %s comming\n", RemoteAddr)
                                l.ServeUDPConn(udpMsg, writeChan)
                                logger.Noticef("client %s exiting\n", RemoteAddr)
                                connChange &lt;- -1</span>
                        }()
                }
        }
        <span class="cov0" title="0">l.netUDPConn.Close()
        close(writeChan)
        close(readChan)
        return nil</span>
}
func (l *udpListener) Addr() string <span class="cov0" title="0">{
        return l.address
}</span>
func (l *udpListener) Close() error <span class="cov7" title="4">{
        return l.netUDPConn.Close()
}</span>

func (l *udpListener) ServeUDPConn(udpMsg *protocol.UDPMsg, writeChan chan *protocol.UDPMsg) error <span class="cov7" title="4">{
        if l.server.multiplexing </span><span class="cov4" title="2">{
                priority, id, body, err := protocol.UnpackFrame(udpMsg.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrConnExit
                }</span>
                <span class="cov4" title="2">ok, resBytes := l.server.Serve(body)
                if resBytes != nil </span><span class="cov4" title="2">{
                        frameBytes := protocol.PacketFrame(priority, id, resBytes)
                        writeChan &lt;- &amp;protocol.UDPMsg{udpMsg.ID, frameBytes, udpMsg.RemoteAddr}
                }</span> else<span class="cov0" title="0"> if ok </span><span class="cov0" title="0">{
                        writeChan &lt;- &amp;protocol.UDPMsg{udpMsg.ID, nil, udpMsg.RemoteAddr}
                }</span>
        } else<span class="cov4" title="2"> {
                ok, resBytes := l.server.Serve(udpMsg.Data)
                if resBytes != nil </span><span class="cov4" title="2">{
                        writeChan &lt;- &amp;protocol.UDPMsg{udpMsg.ID, resBytes, udpMsg.RemoteAddr}
                }</span> else<span class="cov0" title="0"> if ok </span><span class="cov0" title="0">{
                        writeChan &lt;- &amp;protocol.UDPMsg{udpMsg.ID, nil, udpMsg.RemoteAddr}
                }</span>
        }
        <span class="cov7" title="4">return ErrConnExit</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package rpc

import (
        "github.com/gorilla/websocket"
        "hslam.com/git/x/protocol"
        "net/http"
)

var (
        upgrader = websocket.Upgrader{
                ReadBufferSize:  1024 * 64,
                WriteBufferSize: 1024 * 64,
        }
)

type wsListener struct {
        server     *Server
        address    string
        httpServer *http.Server
        maxConnNum int
        connNum    int
}

func listenWS(address string, server *Server) (Listener, error) <span class="cov7" title="4">{
        //lis, err := net.Listen("tcp", address)
        //if err != nil {
        //        logger.Errorf("fatal error: %s", err)
        //        return nil, err
        //}
        httpServer := &amp;http.Server{
                Addr: address,
        }
        l := &amp;wsListener{address: address, httpServer: httpServer, server: server, maxConnNum: DefaultMaxConnNum}
        return l, nil
}</span>
func (l *wsListener) Serve() error <span class="cov7" title="4">{
        logger.Noticef("%s\n", "waiting for clients")
        h := new(wsHandler)
        h.server = l.server
        h.workerChan = make(chan bool, l.maxConnNum)
        h.connChange = make(chan int)
        go func() </span><span class="cov7" title="4">{
                for c := range h.connChange </span><span class="cov10" title="8">{
                        l.connNum += c
                }</span>
        }()
        <span class="cov7" title="4">l.httpServer.Handler = h
        err := l.httpServer.ListenAndServe()
        if err != nil </span><span class="cov7" title="4">{
                if stringsContains(err.Error(), "http: Server closed") </span><span class="cov7" title="4">{
                        return nil
                }</span>
                <span class="cov0" title="0">logger.Errorf("fatal error: %s", err)
                return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (l *wsListener) Addr() string <span class="cov0" title="0">{
        return l.address
}</span>
func (l *wsListener) Close() error <span class="cov7" title="4">{
        return l.httpServer.Close()
}</span>

type wsHandler struct {
        server     *Server
        workerChan chan bool
        connChange chan int
}

func (h *wsHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov7" title="4">{
        r.Header.Del("Origin")
        conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("upgrade : %s\n", err)
                return
        }</span>
        <span class="cov7" title="4">h.workerChan &lt;- true
        func() </span><span class="cov7" title="4">{
                defer func() </span><span class="cov7" title="4">{
                        if err := recover(); err != nil </span>{<span class="cov0" title="0">
                        }</span>
                        <span class="cov7" title="4">&lt;-h.workerChan</span>
                }()
                <span class="cov7" title="4">h.connChange &lt;- 1
                defer func() </span><span class="cov7" title="4">{ h.connChange &lt;- -1 }</span>()
                <span class="cov7" title="4">defer func() </span><span class="cov7" title="4">{ logger.Infof("client %s exiting\n", conn.RemoteAddr()) }</span>()
                <span class="cov7" title="4">logger.Infof("client %s comming\n", conn.RemoteAddr())
                h.server.ServeMessage(&amp;protocol.MsgConn{MessageConn: &amp;websocketConn{conn}})</span>
        }()
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package rpc

import (
        "hslam.com/git/x/log"
)

// LogLevel defines the level for log.
// Higher levels log less info.
type LogLevel int

const (
        logPrefix = "rpc"
        //DebugLevel defines the level of debug in test environments.
        DebugLevel LogLevel = 1
        //TraceLevel defines the level of trace in test environments.
        TraceLevel LogLevel = 2
        //AllLevel defines the lowest level in production environments.
        AllLevel LogLevel = 3
        //InfoLevel defines the level of info.
        InfoLevel LogLevel = 4
        //NoticeLevel defines the level of notice.
        NoticeLevel LogLevel = 5
        //WarnLevel defines the level of warn.
        WarnLevel LogLevel = 6
        //ErrorLevel defines the level of error.
        ErrorLevel LogLevel = 7
        //PanicLevel defines the level of panic.
        PanicLevel LogLevel = 8
        //FatalLevel defines the level of fatal.
        FatalLevel LogLevel = 9
        //OffLevel defines the level of no log.
        OffLevel LogLevel = 10
)

var logger = log.New()

func init() <span class="cov8" title="1">{
        logger.SetPrefix(logPrefix)
        SetLogLevel(InfoLevel)
}</span>

//SetLogLevel sets log's level
func SetLogLevel(level LogLevel) <span class="cov8" title="1">{
        logger.SetLevel(log.Level(level))
}</span>

//GetLogLevel returns log's level
func GetLogLevel() LogLevel <span class="cov0" title="0">{
        return LogLevel(logger.GetLevel())
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package rpc

import "sync"

//Options defines the struct of options.
type Options struct {
        mu               sync.Mutex
        ID               uint64
        MaxRequests      int
        Pipelining       bool
        Multiplexing     bool
        Batching         bool
        MaxBatchRequest  int
        Retry            bool
        CompressType     CompressType
        CompressLevel    CompressLevel
        Timeout          int64
        HeartbeatTimeout int64
        MaxErrPerSecond  int
        MaxErrHeartbeat  int
        NoDelay          bool
        noDelay          bool
}

//DefaultOptions returns a default options.
func DefaultOptions() *Options <span class="cov10" title="27">{
        return &amp;Options{
                ID:               1,
                MaxRequests:      DefaultMaxRequests,
                Pipelining:       false,
                Multiplexing:     true,
                Batching:         false,
                MaxBatchRequest:  DefaultMaxBatchRequest,
                Retry:            true,
                CompressType:     CompressTypeNo,
                CompressLevel:    NoCompression,
                Timeout:          DefaultServerTimeout,
                HeartbeatTimeout: DefaultClientHearbeatTimeout,
                MaxErrPerSecond:  DefaultClientMaxErrPerSecond,
                MaxErrHeartbeat:  DefaultClientMaxErrHeartbeat,
                NoDelay:          false,
                noDelay:          true,
        }
}</span>

//NewOptions creates a new options.
func NewOptions() *Options <span class="cov0" title="0">{
        return DefaultOptions()
}</span>

//Check checks the options.
func (o *Options) Check() <span class="cov10" title="27">{
        o.mu.Lock()
        defer o.mu.Unlock()
        if o.ID &lt; 1 </span><span class="cov0" title="0">{
                o.ID = 1
        }</span>
        <span class="cov10" title="27">if o.MaxRequests &lt; DefaultMaxRequests </span><span class="cov0" title="0">{
                o.MaxRequests = DefaultMaxRequests
        }</span>
        <span class="cov10" title="27">if o.MaxBatchRequest &lt; DefaultMaxBatchRequest </span><span class="cov0" title="0">{
                o.MaxBatchRequest = DefaultMaxBatchRequest
        }</span>
        <span class="cov10" title="27">if o.Pipelining &amp;&amp; o.Multiplexing </span><span class="cov0" title="0">{
                o.Multiplexing = false
        }</span>
        <span class="cov10" title="27">if o.Pipelining || o.Multiplexing </span><span class="cov10" title="27">{
                o.noDelay = false
        }</span>
        <span class="cov10" title="27">if o.Batching </span><span class="cov7" title="10">{
                o.noDelay = true
        }</span>
        <span class="cov10" title="27">if o.NoDelay </span><span class="cov0" title="0">{
                o.noDelay = true
        }</span>
}

//SetMaxRequests sets the number of max requests.
func (o *Options) SetMaxRequests(max int) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.MaxRequests = max
}</span>

//GetMaxRequests returns the number of max requests.
func (o *Options) GetMaxRequests() int <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        return o.MaxRequests
}</span>

//SetPipelining enables pipelining.
func (o *Options) SetPipelining(enable bool) <span class="cov7" title="10">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.Pipelining = enable
        o.Multiplexing = !enable
}</span>

//SetMultiplexing enables multiplexing.
func (o *Options) SetMultiplexing(enable bool) <span class="cov7" title="10">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.Multiplexing = enable
        o.Pipelining = !enable
}</span>

//SetBatching enables batching.
func (o *Options) SetBatching(enable bool) <span class="cov7" title="10">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.Batching = enable
}</span>

//SetMaxBatchRequest sets the number of max batch requests.
func (o *Options) SetMaxBatchRequest(max int) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.MaxBatchRequest = max
}</span>

//GetMaxBatchRequest returns the number of max batch requests.
func (o *Options) GetMaxBatchRequest() int <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        return o.MaxBatchRequest
}</span>

//SetCompressType sets the compress type.
func (o *Options) SetCompressType(compress string) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.CompressType = getCompressType(compress)
}</span>

//SetCompressLevel sets the compress level.
func (o *Options) SetCompressLevel(level string) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.CompressLevel = getCompressLevel(level)
}</span>

//SetID sets the client ID.
func (o *Options) SetID(id uint64) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.ID = id
}</span>

//GetID returns the client ID.
func (o *Options) GetID() uint64 <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        return o.ID
}</span>

//SetTimeout sets the request timeout.
func (o *Options) SetTimeout(timeout int64) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.Timeout = timeout
}</span>

//GetTimeout returns the request timeout.
func (o *Options) GetTimeout() int64 <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        return o.Timeout
}</span>

//SetHeartbeatTimeout sets the heartbeat timeout.
func (o *Options) SetHeartbeatTimeout(timeout int64) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.HeartbeatTimeout = timeout
}</span>

//GetHeartbeatTimeout returns the heartbeat timeout.
func (o *Options) GetHeartbeatTimeout() int64 <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        return o.HeartbeatTimeout
}</span>

//SetMaxErrPerSecond sets the number of max error per second.
func (o *Options) SetMaxErrPerSecond(maxErrPerSecond int) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.MaxErrPerSecond = maxErrPerSecond
}</span>

//GetMaxErrPerSecond returns the number of max error per second.
func (o *Options) GetMaxErrPerSecond() int <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        return o.MaxErrPerSecond
}</span>

//SetMaxErrHeartbeat sets the number of max hearbeat error.
func (o *Options) SetMaxErrHeartbeat(maxErrHeartbeat int) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.MaxErrHeartbeat = maxErrHeartbeat
}</span>

//GetMaxErrHeartbeat returns the number of max hearbeat error.
func (o *Options) GetMaxErrHeartbeat() int <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        return o.MaxErrHeartbeat
}</span>

//SetRetry enables retry.
func (o *Options) SetRetry(enable bool) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.Retry = enable
}</span>

// SetNoDelay controls whether the operating system should delay
// packet transmission in hopes of sending fewer packets (Nagle's
// algorithm).  The default is true (no delay), meaning that data is
// sent as soon as possible after a Write.
func (o *Options) SetNoDelay(enabled bool) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        o.NoDelay = enabled
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package rpc

import (
        "sync"
)

// Dials connects to an RPC server at the specified network address codec
// and returns a pool of clients.
func Dials(total int, network, address, codec string) (*Pool, error) <span class="cov0" title="0">{
        p := &amp;Pool{
                conns: make([]Client, total),
        }
        for i := 0; i &lt; total; i++ </span><span class="cov0" title="0">{
                conn, err := Dial(network, address, codec)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">p.conns[i] = conn</span>
        }
        <span class="cov0" title="0">return p, nil</span>
}

// DialsWithOptions connects to an RPC server at the specified network address codec
// and returns a pool of clients.
func DialsWithOptions(total int, network, address, codec string, opts *Options) (*Pool, error) <span class="cov0" title="0">{
        p := &amp;Pool{
                conns: make([]Client, total),
        }
        for i := 0; i &lt; total; i++ </span><span class="cov0" title="0">{
                conn, err := DialWithOptions(network, address, codec, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">p.conns[i] = conn</span>
        }
        <span class="cov0" title="0">return p, nil</span>
}

//Pool defines the set of clients.
type Pool struct {
        mu    sync.Mutex
        conns []Client
        ID    uint64
}

func (p *Pool) conn() Client <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        if len(p.conns) &lt; 1 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">conn := p.conns[0]
        p.conns = append(p.conns[1:], conn)
        return conn</span>
}
func (p *Pool) head() Client <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        if len(p.conns) &lt; 1 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return p.conns[0]</span>
}

//All returns all clients.
func (p *Pool) All() []Client <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        return p.conns
}</span>

//GetMaxRequests returns the number of max requests.
func (p *Pool) GetMaxRequests() int <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        for _, c := range p.conns </span><span class="cov0" title="0">{
                return c.GetMaxRequests()
        }</span>
        <span class="cov0" title="0">return -1</span>
}

//GetMaxBatchRequest returns the number of max batch requests.
func (p *Pool) GetMaxBatchRequest() int <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        for _, c := range p.conns </span><span class="cov0" title="0">{
                return c.GetMaxBatchRequest()
        }</span>
        <span class="cov0" title="0">return -1</span>
}

//GetID returns a pool id.
func (p *Pool) GetID() uint64 <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        return p.ID
}</span>

//GetTimeout returns the request timeout.
func (p *Pool) GetTimeout() int64 <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        for _, c := range p.conns </span><span class="cov0" title="0">{
                return c.GetTimeout()
        }</span>
        <span class="cov0" title="0">return -1</span>
}

//GetHeartbeatTimeout returns the heartbeat timeout.
func (p *Pool) GetHeartbeatTimeout() int64 <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        for _, c := range p.conns </span><span class="cov0" title="0">{
                return c.GetHeartbeatTimeout()
        }</span>
        <span class="cov0" title="0">return -1</span>
}

//GetMaxErrHeartbeat returns the number of max heartbeat errors.
func (p *Pool) GetMaxErrHeartbeat() int <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        for _, c := range p.conns </span><span class="cov0" title="0">{
                return c.GetMaxErrHeartbeat()
        }</span>
        <span class="cov0" title="0">return -1</span>
}

//GetMaxErrPerSecond returns the number of max errors per second.
func (p *Pool) GetMaxErrPerSecond() int <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        for _, c := range p.conns </span><span class="cov0" title="0">{
                return c.GetMaxErrPerSecond()
        }</span>
        <span class="cov0" title="0">return -1</span>
}

//CodecName returns the codec name.
func (p *Pool) CodecName() string <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        for _, c := range p.conns </span><span class="cov0" title="0">{
                return c.CodecName()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

//CodecType returns the codec type.
func (p *Pool) CodecType() CodecType <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        for _, c := range p.conns </span><span class="cov0" title="0">{
                return c.CodecType()
        }</span>
        <span class="cov0" title="0">return FuncsCodecINVALID</span>
}

// Go invokes the function asynchronously. It returns the Call structure representing
// the invocation. The done channel will signal when the call is complete by returning
// the same Call object. If done is nil, Go will allocate a new channel.
// If non-nil, done must be buffered or Go will deliberately crash.
func (p *Pool) Go(name string, args interface{}, reply interface{}, done chan *Call) *Call <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Go failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">return p.conn().Go(name, args, reply, done)</span>
}

// Call invokes the named function, waits for it to complete, and returns its error status.
func (p *Pool) Call(name string, args interface{}, reply interface{}) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Call failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">return p.conn().Call(name, args, reply)</span>
}

// CallNoRequest invokes the named function but doesn't use args, waits for it to complete, and returns its error status.
func (p *Pool) CallNoRequest(name string, reply interface{}) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("CallNoRequest failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">return p.conn().CallNoRequest(name, reply)</span>
}

// CallNoResponse invokes the named function but doesn't return reply, waits for it to complete, and returns its error status.
func (p *Pool) CallNoResponse(name string, args interface{}) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("CallNoResponse failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">return p.conn().CallNoResponse(name, args)</span>
}

// OnlyCall invokes the named function but doesn't use args and doesn't return reply, waits for it to complete, and returns its error status.
func (p *Pool) OnlyCall(name string) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("OnlyCall failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">return p.conn().OnlyCall(name)</span>
}

// Ping is NOT ICMP ping, this is just used to test whether a connection is still alive.
func (p *Pool) Ping() bool <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorln("Ping failed:", err)
                }</span>
        }()
        <span class="cov0" title="0">return p.head().Ping()</span>
}

// Close closes the connection
func (p *Pool) Close() (err error) <span class="cov0" title="0">{
        for _, c := range p.conns </span><span class="cov0" title="0">{
                err = c.Close()
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Closed returns the closed
func (p *Pool) Closed() bool <span class="cov0" title="0">{
        for _, c := range p.conns </span><span class="cov0" title="0">{
                return c.Closed()
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package rpc

import (
        "fmt"
        "hslam.com/git/x/funcs"
        "hslam.com/git/x/protocol"
        "io"
        "sync"
        "time"
)

var (
        //DefaultServer defines the default server
        DefaultServer = NewServer()
)

//Server defines the struct of server
type Server struct {
        network      string
        listener     Listener
        Funcs        *funcs.Funcs
        timeout      int64
        batching     bool
        pipelining   bool
        multiplexing bool
        asyncMax     int
        noDelay      bool
}

//NewServer creates a new server
func NewServer() *Server <span class="cov1" title="1">{
        return &amp;Server{Funcs: funcs.New(), timeout: DefaultServerTimeout, asyncMax: DefaultMaxAsyncPerConn, multiplexing: true, batching: false}
}</span>

//SetBatching enables batching.
func SetBatching(enable bool) <span class="cov7" title="10">{
        DefaultServer.SetBatching(enable)
}</span>

//SetBatching enables batching.
func (s *Server) SetBatching(enable bool) <span class="cov7" title="10">{
        s.batching = enable
}</span>

//SetNoDelay enables no delay.
func SetNoDelay(enable bool) <span class="cov0" title="0">{
        DefaultServer.SetNoDelay(enable)
}</span>

//SetNoDelay enables no delay.
func (s *Server) SetNoDelay(enable bool) <span class="cov0" title="0">{
        s.noDelay = enable
}</span>

//SetPipelining enables pipelining.
func SetPipelining(enable bool) <span class="cov7" title="10">{
        DefaultServer.SetPipelining(enable)
}</span>

//SetPipelining enables pipelining.
func (s *Server) SetPipelining(enable bool) <span class="cov7" title="10">{
        s.pipelining = enable
        s.multiplexing = !enable
}</span>

//SetMultiplexing enables multiplexing.
func SetMultiplexing(enable bool) <span class="cov7" title="10">{
        DefaultServer.SetMultiplexing(enable)
}</span>

//SetMultiplexing enables multiplexing.
func (s *Server) SetMultiplexing(enable bool) <span class="cov7" title="10">{
        s.multiplexing = enable
        s.pipelining = !enable
        s.SetSize(DefaultMaxMultiplexingPerConn)
}</span>

//SetSize sets the size of max async requests.
func SetSize(size int) <span class="cov0" title="0">{
        DefaultServer.SetSize(size)
}</span>

//SetSize sets the size of max async requests.
func (s *Server) SetSize(size int) <span class="cov7" title="10">{
        s.asyncMax = size
}</span>

// Register publishes in the server the set of methods.
func Register(obj interface{}) error <span class="cov9" title="27">{
        return DefaultServer.Register(obj)
}</span>

// Register publishes in the server the set of methods.
func (s *Server) Register(obj interface{}) error <span class="cov9" title="27">{
        return s.Funcs.Register(obj)
}</span>

// RegisterName is like Register but uses the provided name.
func RegisterName(name string, obj interface{}) error <span class="cov0" title="0">{
        return DefaultServer.RegisterName(name, obj)
}</span>

// RegisterName is like Register but uses the provided name.
func (s *Server) RegisterName(name string, obj interface{}) error <span class="cov0" title="0">{
        return s.Funcs.RegisterName(name, obj)
}</span>

// ListenAndServe listens on the network address addr and then calls Serve.
func ListenAndServe(network, address string) error <span class="cov9" title="27">{
        return DefaultServer.ListenAndServe(network, address)
}</span>

// ListenAndServe listens on the network address addr and then calls Serve.
func (s *Server) ListenAndServe(network, address string) error <span class="cov9" title="27">{
        s.network = network
        listener, err := Listen(network, address, s)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln(err)
                return err
        }</span>
        <span class="cov9" title="27">s.listener = listener
        err = listener.Serve()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorln(err)
                return err
        }</span>
        <span class="cov9" title="23">return nil</span>
}

// Close closes listener
func Close() error <span class="cov9" title="27">{
        return DefaultServer.Close()
}</span>

// Close closes listener
func (s *Server) Close() error <span class="cov9" title="27">{
        return s.listener.Close()
}</span>

// ServeMessage serves message
func ServeMessage(ReadWriteCloser io.ReadWriteCloser) error <span class="cov0" title="0">{
        return DefaultServer.ServeMessage(ReadWriteCloser)
}</span>

// ServeMessage serves message
func (s *Server) ServeMessage(ReadWriteCloser io.ReadWriteCloser) error <span class="cov4" title="4">{
        return s.serve(ReadWriteCloser, false)
}</span>

// ServeConn serves conn
func ServeConn(ReadWriteCloser io.ReadWriteCloser) error <span class="cov0" title="0">{
        return DefaultServer.ServeConn(ReadWriteCloser)
}</span>

// ServeConn serves conn
func (s *Server) ServeConn(ReadWriteCloser io.ReadWriteCloser) error <span class="cov8" title="19">{
        return s.serve(ReadWriteCloser, true)
}</span>
func (s *Server) serve(ReadWriteCloser io.ReadWriteCloser, Stream bool) error <span class="cov9" title="23">{
        readChan := make(chan []byte, 1)
        writeChan := make(chan []byte, 1)
        finishChan := make(chan bool, 2)
        stopReadChan := make(chan bool, 1)
        stopWriteChan := make(chan bool, 1)
        stopChan := make(chan bool, 1)
        if Stream </span><span class="cov8" title="19">{
                go protocol.ReadStream(ReadWriteCloser, readChan, stopReadChan, finishChan)
                var noDelay bool = true
                if !s.batching &amp;&amp; (s.pipelining || s.multiplexing) </span><span class="cov7" title="10">{
                        noDelay = false
                }</span>
                <span class="cov8" title="19">if s.noDelay </span><span class="cov0" title="0">{
                        noDelay = true
                }</span>
                <span class="cov8" title="19">go protocol.WriteStream(ReadWriteCloser, writeChan, stopWriteChan, finishChan, noDelay)</span>
        } else<span class="cov4" title="4"> {
                go protocol.ReadConn(ReadWriteCloser, readChan, stopReadChan, finishChan)
                go protocol.WriteConn(ReadWriteCloser, writeChan, stopWriteChan, finishChan)
        }</span>
        <span class="cov9" title="23">if s.multiplexing </span><span class="cov8" title="15">{
                jobChan := make(chan bool, s.asyncMax)
                for </span><span class="cov10" title="30">{
                        select </span>{
                        case data := &lt;-readChan:<span class="cov8" title="15">
                                go func(data []byte, writeChan chan []byte) </span><span class="cov8" title="15">{
                                        defer func() </span><span class="cov8" title="15">{
                                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                                }</span>
                                                <span class="cov8" title="15">&lt;-jobChan</span>
                                        }()
                                        <span class="cov8" title="15">jobChan &lt;- true
                                        priority, id, body, err := protocol.UnpackFrame(data)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov8" title="15">_, resBytes := s.Serve(body)
                                        if resBytes != nil </span><span class="cov8" title="15">{
                                                frameBytes := protocol.PacketFrame(priority, id, resBytes)
                                                writeChan &lt;- frameBytes
                                        }</span>
                                }(data, writeChan)
                        case stop := &lt;-finishChan:<span class="cov8" title="15">
                                if stop </span><span class="cov8" title="15">{
                                        stopReadChan &lt;- true
                                        stopWriteChan &lt;- true
                                        goto endfor</span>
                                }
                        }
                }
        } else<span class="cov6" title="8"> {
                for </span><span class="cov8" title="16">{
                        select </span>{
                        case data := &lt;-readChan:<span class="cov6" title="8">
                                _, resBytes := s.Serve(data)
                                if resBytes != nil </span><span class="cov6" title="8">{
                                        writeChan &lt;- resBytes
                                }</span>
                        case stop := &lt;-finishChan:<span class="cov6" title="8">
                                if stop </span><span class="cov6" title="8">{
                                        stopReadChan &lt;- true
                                        stopWriteChan &lt;- true
                                        goto endfor</span>
                                }
                        }
                }
        }
endfor:
        <span class="cov9" title="23">defer ReadWriteCloser.Close()
        close(readChan)
        close(writeChan)
        close(finishChan)
        close(stopReadChan)
        close(stopWriteChan)
        close(stopChan)
        return ErrConnExit</span>
}

// Serve serves bytes
func Serve(b []byte) (bool, []byte) <span class="cov0" title="0">{
        return DefaultServer.Serve(b)
}</span>

// Serve serves bytes
func (s *Server) Serve(b []byte) (ok bool, body []byte) <span class="cov9" title="27">{
        ctx := &amp;serverCodec{}
        ctx.Decode(b)
        if ctx.msg.msgType == MsgTypeHea </span><span class="cov0" title="0">{
                return true, b
        }</span>
        <span class="cov9" title="27">ctx.msg.msgType = MsgTypeRes
        var noResponse = false
        var responseBytes []byte
        if ctx.msg.batch </span><span class="cov7" title="10">{
                NoResponseCnt := &amp;count{}
                if ctx.batchCodec.async </span><span class="cov5" title="5">{
                        waitGroup := sync.WaitGroup{}
                        for i, v := range ctx.requests </span><span class="cov5" title="5">{
                                waitGroup.Add(1)
                                go func(i int, req *request, res *response, NoResponseCnt *count, waitGroup *sync.WaitGroup) </span><span class="cov5" title="5">{
                                        defer waitGroup.Done()
                                        s.handle(ctx, req, res)
                                        if req.noResponse == true </span><span class="cov0" title="0">{
                                                NoResponseCnt.add(1)
                                                ctx.responses[i].data = []byte("")
                                        }</span> else<span class="cov5" title="5"> {
                                                body, _ := ctx.responses[i].Encode()
                                                ctx.batchCodec.data[i] = body
                                        }</span>
                                }(i, v, ctx.responses[i], NoResponseCnt, &amp;waitGroup)
                        }
                        <span class="cov5" title="5">waitGroup.Wait()</span>
                } else<span class="cov5" title="5"> {
                        for i, v := range ctx.requests </span><span class="cov5" title="5">{
                                s.handle(ctx, v, ctx.responses[i])
                                if v.noResponse == true </span><span class="cov0" title="0">{
                                        NoResponseCnt.add(1)
                                        ctx.responses[i].data = []byte("")
                                }</span> else<span class="cov5" title="5"> {
                                        body, _ := ctx.responses[i].Encode()
                                        ctx.batchCodec.data[i] = body
                                }</span>
                        }
                }
                <span class="cov7" title="10">if NoResponseCnt.load() == int64(len(ctx.requests)) </span><span class="cov0" title="0">{
                        noResponse = true
                }</span> else<span class="cov7" title="10"> {
                        responseBytes, _ = ctx.batchCodec.Encode()
                }</span>
        } else<span class="cov8" title="17"> {
                s.handle(ctx, ctx.request, ctx.response)
                noResponse = ctx.request.noResponse
                responseBytes, _ = ctx.response.Encode()
        }</span>
        <span class="cov9" title="27">if noResponse == true </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov9" title="27">ctx.msg.data = responseBytes
        body, _ = ctx.Encode()
        return true, body</span>
}

func (s *Server) handle(ctx *serverCodec, req *request, res *response) <span class="cov9" title="27">{
        res.id = req.id
        if s.timeout &gt; 0 </span><span class="cov0" title="0">{
                ch := make(chan int)
                go func() </span><span class="cov0" title="0">{
                        s.callService(ctx, req, res)
                        ch &lt;- 1
                }</span>()
                <span class="cov0" title="0">select </span>{
                case &lt;-ch:<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(time.Millisecond * time.Duration(s.timeout)):<span class="cov0" title="0">
                        res.err = fmt.Errorf("method %s time out", req.method)
                        return</span>
                }
        }
        <span class="cov9" title="27">s.callService(ctx, req, res)</span>
}
func (s *Server) callService(ctx *serverCodec, req *request, res *response) <span class="cov9" title="27">{
        if s.Funcs.GetFunc(req.method) == nil </span><span class="cov0" title="0">{
                logger.Noticef("Server.CallService method %s is not supposted", req.method)
                res.err = fmt.Errorf("Server.CallService method %s is not supposted", req.method)
                return
        }</span>
        <span class="cov9" title="27">if req.noRequest &amp;&amp; req.noResponse </span><span class="cov0" title="0">{
                if err := s.Funcs.Call(req.method); err != nil </span><span class="cov0" title="0">{
                        logger.Noticef("Server.CallService OnlyCall err %s", err)
                        res.err = fmt.Errorf("Server.CallService OnlyCall err %s", err)
                        return
                }</span>
                <span class="cov0" title="0">return</span>
        } else<span class="cov9" title="27"> if req.noRequest &amp;&amp; !req.noResponse </span><span class="cov0" title="0">{
                reply := s.Funcs.GetFuncIn(req.method, 0)
                if err := s.Funcs.Call(req.method, reply); err != nil </span><span class="cov0" title="0">{
                        logger.Noticef("Server.CallService CallNoRequest err %s", err)
                        res.err = fmt.Errorf("Server.CallService CallNoRequest err %s", err)
                        return
                }</span>
                <span class="cov0" title="0">replyBytes, err := replyEncode(reply, ctx.msg.codecType)
                if err != nil </span><span class="cov0" title="0">{
                        res.err = fmt.Errorf("Server.CallService ReplyEncode err %s", err)
                        return
                }</span>
                <span class="cov0" title="0">res.data = replyBytes
                return</span>
        } else<span class="cov9" title="27"> if !req.noRequest &amp;&amp; req.noResponse </span><span class="cov0" title="0">{
                args := s.Funcs.GetFuncIn(req.method, 0)
                err := argsDecode(req.data, args, ctx.msg.codecType)
                if err != nil </span><span class="cov0" title="0">{
                        res.err = fmt.Errorf("Server.CallService ArgsDecode err %s", err)
                        return
                }</span>
                <span class="cov0" title="0">reply := s.Funcs.GetFuncIn(req.method, 1)
                if reply != nil </span><span class="cov0" title="0">{
                        if err := s.Funcs.Call(req.method, args, reply); err != nil </span><span class="cov0" title="0">{
                                res.err = fmt.Errorf("Server.CallService CallNoResponseWithReply err %s", err)
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := s.Funcs.Call(req.method, args); err != nil </span><span class="cov0" title="0">{
                                res.err = fmt.Errorf("Server.CallService CallNoResponseWithoutReply err %s", err)
                                return
                        }</span>
                }
                <span class="cov0" title="0">return</span>

        } else<span class="cov9" title="27"> {
                args := s.Funcs.GetFuncIn(req.method, 0)
                err := argsDecode(req.data, args, ctx.msg.codecType)
                if err != nil </span><span class="cov0" title="0">{
                        res.err = fmt.Errorf("Server.CallService ArgsDecode err %s", err)
                        return
                }</span>
                <span class="cov9" title="27">reply := s.Funcs.GetFuncIn(req.method, 1)
                if err := s.Funcs.Call(req.method, args, reply); err != nil </span><span class="cov0" title="0">{
                        res.err = fmt.Errorf("Server.CallService Call err %s", err)
                        return
                }</span>
                <span class="cov9" title="27">var replyBytes []byte
                replyBytes, err = replyEncode(reply, ctx.msg.codecType)
                if err != nil </span><span class="cov0" title="0">{
                        res.err = fmt.Errorf("Server.CallService ReplyEncode err %s", err)
                        return
                }</span>
                <span class="cov9" title="27">res.data = replyBytes
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package rpc

type syncConn struct {
        server *Server
}

func newSyncConn(server *Server) *syncConn <span class="cov0" title="0">{
        return &amp;syncConn{server: server}
}</span>

func (s *syncConn) Do(requestBody []byte) ([]byte, error) <span class="cov0" title="0">{
        _, resBytes := s.server.Serve(requestBody)
        if resBytes != nil </span><span class="cov0" title="0">{
                return resBytes, nil
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package rpc

import (
        "errors"
        "sync"
        "time"
)

const (
        //MaxConnsPerHost defines the max conn per host
        MaxConnsPerHost = 8
        //MaxIdleConnsPerHost defines the max idle conn per host
        MaxIdleConnsPerHost = 2
        keepAlive           = time.Minute
)

//Transport defines the struct of transport
type Transport struct {
        mut                 sync.Mutex
        once                sync.Once
        proxys              []*Proxy
        MaxConnsPerHost     int
        MaxIdleConnsPerHost int
        Network             string
        Codec               string
        Options             *Options
}

//NewTransport creates a new transport.
func NewTransport(MaxConnsPerHost int, MaxIdleConnsPerHost int, network, codec string, opts *Options) *Transport <span class="cov0" title="0">{
        if MaxConnsPerHost &lt; 1 </span><span class="cov0" title="0">{
                MaxConnsPerHost = 1
        }</span>
        <span class="cov0" title="0">if MaxIdleConnsPerHost &lt; 0 </span><span class="cov0" title="0">{
                MaxIdleConnsPerHost = 0
        }</span>
        <span class="cov0" title="0">t := &amp;Transport{
                MaxConnsPerHost:     MaxConnsPerHost,
                MaxIdleConnsPerHost: MaxIdleConnsPerHost,
                Network:             network,
                Codec:               codec,
                Options:             opts,
        }
        return t</span>
}
func (t *Transport) run() <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Second)
        for range ticker.C </span><span class="cov0" title="0">{
                func() </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if err := recover(); err != nil </span>{<span class="cov0" title="0">
                                }</span>
                        }()
                        <span class="cov0" title="0">t.mut.Lock()
                        defer t.mut.Unlock()
                        idles := []int{}
                        for i, r := range t.proxys </span><span class="cov0" title="0">{
                                r.check()
                                if len(r.clients) == 0 </span><span class="cov0" title="0">{
                                        idles = append(idles, i)
                                }</span>
                        }
                        <span class="cov0" title="0">for _, i := range idles </span><span class="cov0" title="0">{
                                if len(idles) &lt;= t.MaxIdleConnsPerHost </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">t.proxys = append(t.proxys[:i], t.proxys[i+1:]...)</span>
                        }
                }()

        }
}

//GetProxy returns a proxy
func (t *Transport) GetProxy() *Proxy <span class="cov0" title="0">{
        t.once.Do(func() </span><span class="cov0" title="0">{
                go t.run()
        }</span>)
        <span class="cov0" title="0">t.mut.Lock()
        defer t.mut.Unlock()
        if len(t.proxys) &lt; t.MaxConnsPerHost </span><span class="cov0" title="0">{
                proxy := NewProxy(t.Network, t.Codec, t.Options)
                t.proxys = append(t.proxys, proxy)
                return proxy
        }</span>
        <span class="cov0" title="0">rpcs := t.proxys[0]
        t.proxys = append(t.proxys[1:], rpcs)
        return rpcs</span>
}

//GetConn returns a proxy client
func (t *Transport) GetConn(addr string) *ProxyClient <span class="cov0" title="0">{
        proxy := t.GetProxy()
        if proxy != nil </span><span class="cov0" title="0">{
                conn := proxy.GetConn(addr)
                if conn != nil </span><span class="cov0" title="0">{
                        return conn
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Ping is NOT ICMP ping, this is just used to test whether a connection is still alive.
func (t *Transport) Ping(address string) bool <span class="cov0" title="0">{
        proxy := t.GetProxy()
        if proxy != nil </span><span class="cov0" title="0">{
                return proxy.Ping(address)
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Call invokes the named function, waits for it to complete, and returns its error status.
func (t *Transport) Call(name string, args interface{}, reply interface{}, address string) error <span class="cov0" title="0">{
        proxy := t.GetProxy()
        if proxy != nil </span><span class="cov0" title="0">{
                return proxy.Call(name, args, reply, address)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Go invokes the function asynchronously. It returns the Call structure representing
// the invocation. The done channel will signal when the call is complete by returning
// the same Call object. If done is nil, Go will allocate a new channel.
// If non-nil, done must be buffered or Go will deliberately crash.
func (t *Transport) Go(name string, args interface{}, reply interface{}, done chan *Call, address string) *Call <span class="cov0" title="0">{
        proxy := t.GetProxy()
        if proxy != nil </span><span class="cov0" title="0">{
                return proxy.Go(name, args, reply, done, address)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//Proxy defines the struct of proxy.
type Proxy struct {
        mu      sync.RWMutex
        clients map[string]*ProxyClient
        Network string
        Codec   string
        Options *Options
}

//ProxyClient defines the struct of proxy client.
type ProxyClient struct {
        Client
        lastTime  time.Time
        keepAlive time.Duration
}

//NewProxy creates a new proxy.
func NewProxy(network, codec string, opts *Options) *Proxy <span class="cov0" title="0">{
        t := &amp;Proxy{
                clients: make(map[string]*ProxyClient),
                Network: network,
                Codec:   codec,
                Options: opts,
        }
        return t
}</span>

func (t *Proxy) getClients() map[string]*ProxyClient <span class="cov0" title="0">{
        if t.clients == nil </span><span class="cov0" title="0">{
                t.clients = make(map[string]*ProxyClient)
        }</span>
        <span class="cov0" title="0">return t.clients</span>
}

func (t *Proxy) check() <span class="cov0" title="0">{
        for addr, conn := range t.getClients() </span><span class="cov0" title="0">{
                if conn.lastTime.Add(conn.keepAlive).Before(time.Now()) </span><span class="cov0" title="0">{
                        t.RemoveConn(addr)
                }</span>
        }
}

//GetConn returns a proxy client
func (t *Proxy) GetConn(address string) *ProxyClient <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        if _, ok := t.getClients()[address]; ok </span><span class="cov0" title="0">{
                return t.getClients()[address]
        }</span>
        <span class="cov0" title="0">conn, err := t.NewConn(address)
        if err == nil </span><span class="cov0" title="0">{
                c := &amp;ProxyClient{conn, time.Now(), keepAlive}
                t.getClients()[address] = c
                return t.getClients()[address]
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//RemoveConn remove a proxy client by address.
func (t *Proxy) RemoveConn(address string) <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        if conn, ok := t.getClients()[address]; ok </span><span class="cov0" title="0">{
                delete(t.getClients(), address)
                go func(conn Client) </span><span class="cov0" title="0">{
                        time.Sleep(keepAlive)
                        conn.Close()
                }</span>(conn)
        }
}

//NewConn creates a client by address.
func (t *Proxy) NewConn(address string) (Client, error) <span class="cov0" title="0">{
        return DialWithOptions(t.Network, address, t.Codec, t.Options)
}</span>

// Ping is NOT ICMP ping, this is just used to test whether a connection is still alive.
func (t *Proxy) Ping(addr string) bool <span class="cov0" title="0">{
        conn := t.GetConn(addr)
        if conn != nil </span><span class="cov0" title="0">{
                if conn.Ping() </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">t.RemoveConn(addr)
        return false</span>
}

// Call invokes the named function, waits for it to complete, and returns its error status.
func (t *Proxy) Call(name string, args interface{}, reply interface{}, addr string) error <span class="cov0" title="0">{
        conn := t.GetConn(addr)
        if conn != nil </span><span class="cov0" title="0">{
                err := conn.Call(name, args, reply)
                if err != nil </span><span class="cov0" title="0">{
                        t.RemoveConn(addr)
                        return err
                }</span>
                <span class="cov0" title="0">conn.lastTime = time.Now()
                return nil</span>
        }
        <span class="cov0" title="0">return errors.New("Proxy.Call can not connect to " + addr)</span>
}

// Go invokes the function asynchronously. It returns the Call structure representing
// the invocation. The done channel will signal when the call is complete by returning
// the same Call object. If done is nil, Go will allocate a new channel.
// If non-nil, done must be buffered or Go will deliberately crash.
func (t *Proxy) Go(name string, args interface{}, reply interface{}, done chan *Call, addr string) *Call <span class="cov0" title="0">{
        conn := t.GetConn(addr)
        if conn != nil </span><span class="cov0" title="0">{
                call := conn.Go(name, args, reply, nil)
                if call.Error != nil </span><span class="cov0" title="0">{
                        t.RemoveConn(addr)
                        return call
                }</span>
                <span class="cov0" title="0">conn.lastTime = time.Now()
                return call</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package rpc

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/tls"
        "crypto/x509"
        "encoding/binary"
        "encoding/pem"
        "math"
        "math/big"
        "strings"
)

func uint16ToBytes(n uint16) []byte <span class="cov0" title="0">{
        return []byte{
                byte(n),
                byte(n &gt;&gt; 8),
        }
}</span>
func bytesToUint16(array []byte) uint16 <span class="cov0" title="0">{
        var data uint16 = 0
        for i := 0; i &lt; len(array); i++ </span><span class="cov0" title="0">{
                data = data + uint16(uint(array[i])&lt;&lt;uint(8*i))
        }</span>
        <span class="cov0" title="0">return data</span>
}
func uint32ToBytes(n uint32) []byte <span class="cov0" title="0">{
        return []byte{
                byte(n),
                byte(n &gt;&gt; 8),
                byte(n &gt;&gt; 16),
                byte(n &gt;&gt; 24),
        }
}</span>
func bytesToUint32(array []byte) uint32 <span class="cov0" title="0">{
        var data uint32 = 0
        for i := 0; i &lt; len(array); i++ </span><span class="cov0" title="0">{
                data = data + uint32(uint(array[i])&lt;&lt;uint(8*i))
        }</span>
        <span class="cov0" title="0">return data</span>
}
func float32ToByte(float float32) []byte <span class="cov0" title="0">{
        bits := math.Float32bits(float)
        bytes := make([]byte, 4)
        binary.LittleEndian.PutUint32(bytes, bits)
        return bytes
}</span>

func byteToFloat32(bytes []byte) float32 <span class="cov0" title="0">{
        bits := binary.LittleEndian.Uint32(bytes)
        return math.Float32frombits(bits)
}</span>

func float64ToByte(float float64) []byte <span class="cov0" title="0">{
        bits := math.Float64bits(float)
        bytes := make([]byte, 8)
        binary.LittleEndian.PutUint64(bytes, bits)
        return bytes
}</span>

func byteToFloat64(bytes []byte) float64 <span class="cov0" title="0">{
        bits := binary.LittleEndian.Uint64(bytes)
        return math.Float64frombits(bits)
}</span>
func stringsContains(s, substr string) bool <span class="cov10" title="23">{
        return strings.Contains(s, substr)
}</span>
func checkSum(b []byte) uint16 <span class="cov0" title="0">{
        sum := 0
        for n := 1; n &lt; len(b)-1; n += 2 </span><span class="cov0" title="0">{
                sum += int(b[n])&lt;&lt;8 + int(b[n+1])
        }</span>
        <span class="cov0" title="0">lowbit := sum &amp; 0xffff
        highbit := sum &gt;&gt; 16
        checksum := lowbit + highbit
        checksum += (checksum &gt;&gt; 16)
        var ans = uint16(^checksum)
        return ans</span>
}
func generateQuicTLSConfig() *tls.Config <span class="cov4" title="4">{
        key, err := rsa.GenerateKey(rand.Reader, 1024)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov4" title="4">template := x509.Certificate{SerialNumber: big.NewInt(1)}
        certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;key.PublicKey, key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov4" title="4">keyPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(key)})
        certPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "CERTIFICATE", Bytes: certDER})

        tlsCert, err := tls.X509KeyPair(certPEM, keyPEM)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov4" title="4">return &amp;tls.Config{
                Certificates: []tls.Certificate{tlsCert},
                NextProtos:   []string{"quic-rpc"},
        }</span>
}
func generateTLSConfig() *tls.Config <span class="cov0" title="0">{
        key, err := rsa.GenerateKey(rand.Reader, 1024)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">template := x509.Certificate{SerialNumber: big.NewInt(1)}
        certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;key.PublicKey, key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">keyPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(key)})
        certPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "CERTIFICATE", Bytes: certDER})

        tlsCert, err := tls.X509KeyPair(certPEM, keyPEM)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return &amp;tls.Config{
                Certificates: []tls.Certificate{tlsCert},
        }</span>
}

func defalutTLSConfig() *tls.Config <span class="cov0" title="0">{
        keyPEM := []byte(`-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDQx2lxR73msUrD
EthvjZCG8nmxY/m6ZXBRdaygc++Ie4baSHgS5DsLUcMEPhUOzzkUjjvc9dFy/ROD
yw/hL1jmgC2a8bA+czWlK1V6tP/bkEzy9MZpUIM7aY48W0/t4O9ZaRML8zavfozo
Vq5UXoS6meIzS5afg6vVNFB9bLV/d/AmT86BdZ0PYUzYg4KJcGT2nFJnEecjBFjj
khIzhQs02IxaHH7xiddcIjZpzXEcaGFxJGecDFe+LFHIN9pgCG17kppK2Ebt93ck
EpIM1LuiemX2CBckBlXCACrIVkeQ6pJTKcEMFbEcU9zYz8G9Apu3CgZApQUxuSlc
VbdStupHAgMBAAECggEBAMfqm0I441Pa4u8Gxa+UDBfcacD+LaxZ5AJsvt9qBK1Z
M5kjma7lUtCU+zu9wuZKcasIQ7RiwqvsQFqMAGmtr+AQTxs2YYB7S5wccZ6tYO67
L6PZ1YAU84TZn7SV72SmZirknbNssim78WutTQNG+qvAHMTnlZSrPchLbuObS/SA
hufs9fqxzBUeVXVE18vyhBq4i2SRyKcBxKEPRdzhbYem8SPi7hr/NnPomNUOr8Cw
JGY0XsD6MVs4myzdpPRTNL8farzvpmLdJ9C1Nc8DKIwZZsoGkoMXXxtqJzYUYp7C
deqUCMJY381R3mJUpUd6RU2ocL521CyA2YinGKljspkCgYEA60CC0B0I2cQ+W1Bf
i/E5rItT91cseCJTnpH9m2ok3Pe4CiO/BLK9Ew9rjlHb7wNofch/EwNb4veIxRf8
2MMjBuecTvqn/akirtPtjDPuQoKW7yBEKjqW8+yt97INHhMVkhMkoZ4JTmq2gWJg
oT02Eq9YN52dpJjqYM7OvSywHPUCgYEA4zEyKo1/KWNNCCyBMlmPzRNyhxLk0h+t
84UlwTKRogsQLgkZrseRMKakiHjF4Ez6qczC5MrHqH4I3e5RrAQP9uNQJIA0g+Ma
mhpI5xq1ZnkCq/Z69K808trzFS4rAS7NZfwn8mV0ZXFHzmTDH1tDEvg+NXUXykFE
zI15yYyXpMsCgYEA1QSaLvZLgFyplifGDMLGVY3n3yzJcJKsowZQ3PyVGp0Ywd2y
Zv+uI2cwHjPTca7lXBhDsKS2/GLmLonVAzZXLjZlHELuAMu5QxNVo0GWuhTjtO3D
q3VYINGsiYBpTlU7kATTg6DFjoMkdS3uj7IMl4i82cdX6qYofLZnD3c6lU0CgYBZ
t1uwIiBNH8GTsL90Opnmyf84B+YEdC4lNDcsi+Omsee5xi42LujO5X+jxM2fPcbe
ttVftBQUHXEy8qGd5BzJygoj39zdGBmxMSAI4ysvRCoh7juv1GB8ZqoHeyvQU8MY
uvKrbhUA2jMY9gF3qHpcS1uFkK/MVunsPRIS3Uok8QKBgGq5Auz3ByjA9gKPk8qO
p8S35+ldnAnIsMeojW+rXmUBrHaSp9ea9+obFHp1JKjI4dMoT92EKRAU5nnM3iqR
q2/umYjD1XcbHSRdxz8H7hkZfQ4GSAwG/KNeGWL5FRSq3p6WeobLL4WdTcugS5cz
cXoVckT5dS+Mj/SxSJ/oyvyu
-----END PRIVATE KEY-----
`)
        certPEM := []byte(`-----BEGIN CERTIFICATE-----
MIIDbjCCAlYCCQCZymVmCboLuDANBgkqhkiG9w0BAQsFADB4MQswCQYDVQQGEwJD
TjELMAkGA1UECAwCQkoxCzAJBgNVBAcMAkJKMQ4wDAYDVQQKDAVobHNhbTEOMAwG
A1UECwwFaHNsYW0xDjAMBgNVBAMMBWhzbGFtMR8wHQYJKoZIhvcNAQkBFhA3OTE4
NzQxNThAcXEuY29tMCAXDTE5MTEwODEzNDYzNloYDzIxMTkxMDE1MTM0NjM2WjB4
MQswCQYDVQQGEwJDTjELMAkGA1UECAwCQkoxCzAJBgNVBAcMAkJKMQ4wDAYDVQQK
DAVobHNhbTEOMAwGA1UECwwFaHNsYW0xDjAMBgNVBAMMBWhzbGFtMR8wHQYJKoZI
hvcNAQkBFhA3OTE4NzQxNThAcXEuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEA0MdpcUe95rFKwxLYb42QhvJ5sWP5umVwUXWsoHPviHuG2kh4EuQ7
C1HDBD4VDs85FI473PXRcv0Tg8sP4S9Y5oAtmvGwPnM1pStVerT/25BM8vTGaVCD
O2mOPFtP7eDvWWkTC/M2r36M6FauVF6EupniM0uWn4Or1TRQfWy1f3fwJk/OgXWd
D2FM2IOCiXBk9pxSZxHnIwRY45ISM4ULNNiMWhx+8YnXXCI2ac1xHGhhcSRnnAxX
vixRyDfaYAhte5KaSthG7fd3JBKSDNS7onpl9ggXJAZVwgAqyFZHkOqSUynBDBWx
HFPc2M/BvQKbtwoGQKUFMbkpXFW3UrbqRwIDAQABMA0GCSqGSIb3DQEBCwUAA4IB
AQBMfGE+zL6XMc/CJK59rRJQdypFG2gPxzpHi4XXTUfTAAYhZZRMYfiefxII8s5V
MG+n+c1wU/nubE3xj9dgq7aIC1L3EPyVkWu/s8lPNWKMOO1FchZghBHYsImD5uM6
sD1euV5nOmPnirK/vrfBuemGLtOFEgDrCEk39bd8AWLgrdpeqfVpW4K6QkDh1V4u
Qe2ZVXa6qRwJ8dAvo79JmW8txruJ6/5s4Af7Gogr/F2BHYlbLMgdjAYTOT0X7mOs
ZtmM8OaZrcg7EDEFHsV3k56S6i4EUH2VDOCz+v2BAJmWqDwVmjI4kEKKbgjI9fwv
st022MDOYYU7dKz1lAiLJr1G
-----END CERTIFICATE-----
`)
        tlsCert, err := tls.X509KeyPair(certPEM, keyPEM)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return &amp;tls.Config{Certificates: []tls.Certificate{tlsCert}}</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package rpc

import (
        "github.com/gorilla/websocket"
)

type websocketConn struct {
        *websocket.Conn
}

func (s *websocketConn) ReadMessage() (p []byte, err error) <span class="cov10" title="16">{
        _, data, err := s.Conn.ReadMessage()
        return data, err
}</span>

func (s *websocketConn) WriteMessage(b []byte) (err error) <span class="cov8" title="11">{
        return s.Conn.WriteMessage(websocket.BinaryMessage, b)
}</span>

func (s *websocketConn) Close() error <span class="cov7" title="8">{
        return s.Conn.Close()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
